<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Gutter Estimator v12.5.2</title>
<style>
body { margin:0; font-family:Arial; overflow:hidden; }
#toolbar {
  background:#ddd;
  padding:8px;
  display:flex;
  flex-direction:column;
  gap:6px;
}
.toolbar-row{
  display:flex;
  gap:6px;
  align-items:center;
  flex-wrap:wrap;
}
canvas { display:block; width:100vw; cursor:crosshair; }
button { padding:4px 8px; }

.color-btn { width:22px;height:22px;border:2px solid #333;cursor:pointer; }
.color-btn.active { outline:3px solid orange; }
.tool-btn.active { background:#444;color:white; }

/* Floating inventory panel (modern, top-right) */
#inventoryPanel{
  position:fixed;
  right:14px;
  top:14px;

  background:rgba(255,255,255,0.92);
  border:1px solid rgba(0,0,0,0.18);
  border-radius:12px;
  padding:12px 14px;
  min-width:210px;

  box-shadow:0 10px 26px rgba(0,0,0,0.18);
  backdrop-filter: blur(6px);
  -webkit-backdrop-filter: blur(6px);

  z-index:9999;
  user-select:none;
}
#inventoryPanel.hidden{ display:none; }
#inventoryTitle{
  font-weight:800;
  font-size:14px;
  letter-spacing:0.2px;
  margin-bottom:8px;

  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}
#inventoryClose{
  padding:2px 8px;
  line-height:1;
  border-radius:8px;
  border:1px solid rgba(0,0,0,0.18);
  background:rgba(0,0,0,0.04);
  cursor:pointer;
}
#inventoryClose:hover{ background:rgba(0,0,0,0.08); }

.invRow{
  display:flex;
  justify-content:space-between;
  gap:12px;
  padding:4px 0;
  font-size:13px;
}
.invRow + .invRow{
  border-top:1px solid rgba(0,0,0,0.07);
}
.invRow .label{ color:#222; }
.invRow .value{ font-weight:800; color:#111; }

.invEmpty{
  font-size:13px;
  color:#333;
  padding:6px 0 2px 0;
}
.invSub{
  font-size:11px;
  color:#555;
  margin-top:8px;
}

/* --- Customer Info side panel --- */
#infoPanel{
  position:fixed;
  top:0;
  right:0;
  height:100vh;
  width:clamp(300px, 34vw, 80vw);
  max-width:80vw;
  background:#f7f7f7;
  border-left:1px solid #bbb;
  box-shadow:-6px 0 18px rgba(0,0,0,0.18);
  transform:translateX(100%);
  transition:transform 0.22s ease;
  z-index:9999;
  display:flex;
  flex-direction:column;
}
#infoPanel.open{ transform:translateX(0); }
#infoPanelHeader{
  padding:10px 12px;
  background:#e6e6e6;
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:bold;
}
#infoPanelHeader button{
  padding:2px 8px;
  font-size:18px;
  line-height:18px;
}
#infoPanelBody{
  padding:12px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}
.ciRow{ display:flex; flex-direction:column; gap:4px; }

.ciRow2{ display:flex; gap:10px; }
.ciField{ flex:1; display:flex; flex-direction:column; gap:4px; }

/* Modernize Customer Info inputs only */
#infoPanelBody input{
  padding:10px;
  border:1px solid #cfcfcf;
  border-radius:10px;
  font-size:14px;
  background:#fff;
}
#infoPanelBody input:focus{
  outline:none;
  border-color:#4a90e2;
  box-shadow:0 0 0 2px rgba(74,144,226,.22);
}


/* --- Customer Info labels: unified style (ciRow + ciField) --- */
#infoPanelBody label{
  font-size:13px !important;
  font-weight:400 !important;
  font-family:Arial, sans-serif !important;
  color:#333 !important;
  line-height:1.2 !important;
  letter-spacing:0 !important;
  transform:none !important;
}

/* --- Project side panel --- */
#projectPanel{
  position:fixed;
  top:0;
  right:0;
  height:100vh;
  width:clamp(300px, 34vw, 80vw);
  max-width:80vw;
  background:#f7f7f7;
  border-left:1px solid #bbb;
  box-shadow:-6px 0 18px rgba(0,0,0,0.18);
  transform:translateX(100%);
  transition:transform .18s ease;
  z-index:22000;
}
#projectPanel.open{ transform:translateX(0); }
#projectPanelHeader{
  padding:10px 12px;
  background:#e6e6e6;
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:bold;
}
#projectPanelBody{
  padding:12px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}


.ciRow label{
  font-size:14px;
  font-weight:600;
  color:#333;
}
.ciRow input{
  padding:6px 8px;
  border:1px solid #bbb;
  border-radius:6px;
  font-size:14px;
}

/* --- Left tool panel --- */

/* --- Left panel modern style (CSS-only facelift) --- */
#leftPanel{
  position:fixed;
  left:0;
  top:0;              /* adjusted by JS to sit under toolbar */
  width:184px;
  padding:12px;
  background:#f2f2f2;
  border-right:1px solid rgba(0,0,0,0.14);
  box-shadow:6px 0 18px rgba(0,0,0,0.10);
  z-index:9000;
  display:flex;
  flex-direction:column;
  gap:10px;

  bottom:0;
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
  overscroll-behavior:contain;
}

/* All buttons inside left panel look consistent */
#leftPanel button{
  width:100%;
  text-align:left;
  padding:10px 10px;
  border-radius:14px;
  border:1px solid rgba(0,0,0,0.16);
  background:rgba(255,255,255,0.96);
  cursor:pointer;
  font-size:14px;
  line-height:1.1;
  box-shadow:0 1px 0 rgba(0,0,0,0.05);
  user-select:none;
}
#leftPanel button:hover{
  background:rgba(255,255,255,1);
  border-color:rgba(0,0,0,0.22);
}
#leftPanel button:active{
  transform:translateY(1px);
}

/* Active tool matches bottom toolbar language */
#leftPanel .tool-btn.active{
  background:#cfd6dc;
  border-color:#7a8794;
  box-shadow:inset 0 0 0 2px rgba(0,0,0,0.08);
}

/* Separators + spacer */
#leftPanel #leftPanel .lp-spacer{ flex:1; }

/* Tighten nested injected sub-options (covers/pvc/etc) if they render as buttons */
#leftPanel .subRow button,
#leftPanel .sub-options button{
  border-radius:12px;
  padding:9px 10px;
  font-size:13px;
  background:rgba(255,255,255,0.92);
}

/* --- Inventory side panel (matches Customer Info style) --- */
#inventoryPanel{
  position:fixed;
  top:0;
  right:0;
  height:100vh;
  width:clamp(300px, 34vw, 80vw);
  max-width:80vw;
  background:#f7f7f7;
  border-left:1px solid #bbb;
  box-shadow:-6px 0 18px rgba(0,0,0,0.18);
  transform:translateX(100%);
  transition:transform 0.22s ease;
  z-index:9998; /* under Customer Info */
  display:flex;
  flex-direction:column;
}
#inventoryPanel.open{ transform:translateX(0); }

#inventoryHeader{
  padding:10px 12px;
  background:#e6e6e6;
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:bold;
}
#inventoryHeader button{
  padding:2px 8px;
  font-size:18px;
  line-height:18px;
}
#inventoryBody{
  padding:12px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}
#inventoryBody .invRow{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:6px 8px;
  border:1px solid #d0d0d0;
  border-radius:8px;
  background:#fff;
}
#inventoryBody .invEmpty{
  padding:10px 8px;
  border:1px dashed #c8c8c8;
  border-radius:8px;
  background:#fafafa;
}



/* --- Toast (non-blocking save confirmation) --- */
#toastContainer{
  position:fixed;
  left:50%;
  bottom:96px;
  transform:translateX(-50%);
  z-index:10050;
  pointer-events:none;
}
.toast{
  background:rgba(20,20,20,0.92);
  color:#fff;
  border-radius:12px;
  padding:10px 14px;
  font-size:13px;
  box-shadow:0 10px 26px rgba(0,0,0,0.25);
  margin-top:8px;
  opacity:0;
  transform:translateY(10px);
  transition:opacity 160ms ease, transform 160ms ease;
  max-width:min(92vw, 520px);
  white-space:pre-line;
}
.toast.show{
  opacity:1;
  transform:translateY(0);
}


/* --- Settings side panel (matches Customer Info style) --- */
#settingsPanel{
  position:fixed;
  top:0;
  right:0;
  height:100vh;
  width:clamp(300px, 34vw, 80vw);
  max-width:80vw;
  background:#f7f7f7;
  border-left:1px solid #bbb;
  box-shadow:-6px 0 18px rgba(0,0,0,0.18);
  transform:translateX(100%);
  transition:transform 0.22s ease;
  z-index:9997; /* under Inventory & Customer Info */
  display:flex;
  flex-direction:column;
}
#upgradesPanel{
  position:fixed;
  top:0;
  right:0;
  height:100vh;
  width:clamp(300px, 34vw, 80vw);
  max-width:80vw;
  background:#f7f7f7;
  border-left:1px solid #bbb;
  box-shadow:-6px 0 18px rgba(0,0,0,0.18);
  transform:translateX(100%);
  transition:transform 0.22s ease;
  z-index:9997; /* under Inventory & Customer Info */
  display:flex;
  flex-direction:column;
}

#settingsPanel.open{ transform:translateX(0); }
#upgradesPanel.open{ transform:translateX(0); }
#settingsPanelHeader{
  padding:10px 12px;
  background:#e6e6e6;
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:bold;
}
#upgradesPanelHeader{
  padding:10px 12px;
  background:#e6e6e6;
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:bold;
}

#settingsPanelHeader button{
  padding:2px 8px;
  font-size:18px;
  line-height:18px;
}
#settingsPanelBody{
  padding:12px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}
#upgradesPanelBody{
  padding:12px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}

.setRow{ display:flex; flex-direction:column; gap:6px; }
.setRow label{ font-size:12px; color:#333; }
.setRow .hint{ font-size:11px; color:#666; line-height:1.3; }


/* Hide left panel dropdown titles (dropdowns only) */
#leftPanel .lp-row > span {
  display:none;
}


/* Left panel: hide any leftover labels before dropdowns */
#leftPanel span {
  display:none;
}


/* --- Left panel nested option buttons (replaces dropdowns) --- */
#leftPanel .optGroup{
  display:flex;
  flex-direction:column;
  gap:6px;
  padding-left:10px;
  margin-top:-2px;
}
#leftPanel .optGroup .optBtn{
  width:75%;
  text-align:left;
  padding:6px 8px;
  border:1px solid rgba(0,0,0,0.18);
  background:#fff;
  border-radius:10px;
  cursor:pointer;
  font-size:13px;
}
#leftPanel .optGroup .optBtn.active{
  outline:2px solid orange;
}


/* Only one left-panel tool option group expanded at a time */
#leftPanel .optGroup.collapsed{ display:none; }


/* Fix: hide any accidentally empty option buttons */
#leftPanel .optBtn:empty{ display:none !important; }


#leftPanel .optGroup{
  align-items:flex-start;
}
#leftPanel .optGroup .optBtn{
  margin-left:8px;
}


/* Right-align nested option pills */
#leftPanel .optGroup{
  align-items:flex-end;
}
#leftPanel .optGroup .optBtn{
  margin-left:0;
  margin-right:8px;
}


/* --- Unified Right Panels (Customer Info / Inventory / Settings) --- */
#infoPanel, #inventoryPanel, #settingsPanel{
  position:fixed;
  top:0;
  right:0;
  height:100vh;
  width:clamp(300px, 34vw, 80vw);
  max-width:80vw;
  background:#f7f7f7;
  border-left:1px solid #bbb;
  box-shadow:-6px 0 18px rgba(0,0,0,0.18);
  transform:translateX(100%);
  transition:transform 0.22s ease;
  z-index:9999;
  display:flex;
  flex-direction:column;
}
#infoPanel.open, #inventoryPanel.open, #settingsPanel.open{ transform:translateX(0); }
#upgradesPanel.open{ transform:translateX(0); }

/* Headers */
#infoPanelHeader, #inventoryHeader, #settingsPanelHeader{
  padding:10px 12px;
  background:#e6e6e6;
  display:flex;
  align-items:center;
  justify-content:space-between;
  font-weight:bold;
}
#infoPanelHeader button, #inventoryHeader button, #settingsPanelHeader button{
  padding:2px 8px;
  font-size:18px;
  line-height:18px;
}

/* Bodies */
#infoPanelBody, #inventoryBody, #settingsPanelBody{
  padding:12px;
  overflow:auto;
  display:flex;
  flex-direction:column;
  gap:10px;
}

/* Make inventory rows match the panel style */
#inventoryBody .invRow{
  display:flex;
  justify-content:space-between;
  align-items:center;
  padding:6px 8px;
  border:1px solid #d0d0d0;
  border-radius:8px;
  background:#fff;
}
#inventoryBody .invEmpty{
  padding:10px 8px;
  border:1px dashed #c8c8c8;
  border-radius:8px;
  background:#fafafa;
}


/* --- v7.1.0 Strong Right Panel Overrides (unify look + no rounded corners) --- */
#infoPanel, #inventoryPanel, #settingsPanel{
  border-radius:0 !important;
  background:#f7f7f7 !important;
  box-shadow:-6px 0 18px rgba(0,0,0,0.18) !important;
  border-left:1px solid #bbb !important;
  top:0 !important;
  right:0 !important;
  height:100vh !important;
  width:clamp(300px, 34vw, 80vw) !important;
  max-width:80vw !important;
  transform:translateX(100%) !important;
  transition:transform 0.22s ease !important;
  display:flex !important;
  flex-direction:column !important;
}
#infoPanel{ z-index:10003 !important; }
#inventoryPanel{ z-index:10002 !important; }
#settingsPanel{ z-index:10001 !important; }

#infoPanel.open, #inventoryPanel.open, #settingsPanel.open{
  transform:translateX(0) !important;
}

#infoPanelHeader, #inventoryHeader, #settingsPanelHeader{
  border-radius:0 !important;
  padding:10px 12px !important;
  background:#e6e6e6 !important;
  display:flex !important;
  align-items:center !important;
  justify-content:space-between !important;
  font-weight:bold !important;
}
#infoPanelBody, #inventoryBody, #settingsPanelBody{
  padding:12px !important;
  overflow:auto !important;
  display:flex !important;
  flex-direction:column !important;
  gap:10px !important;
}


/* Pull bottom action buttons up slightly */
#leftPanel .lp-spacer{
  flex:0.95;
}


/* --- Required field error state --- */
.req-error{
  outline:2px solid #d93025 !important;
  background:#fff5f5 !important;
}


/* --- Inventory: Misc items --- */
#inventoryBody .miscSpacer{ height:12px; }
#inventoryBody .miscHeader{ font-size:12px; color:#333; margin-top:4px; }
#inventoryBody .miscList{ display:flex; flex-direction:column; gap:8px; }
#inventoryBody .miscForm{
  display:flex; gap:8px; align-items:center; flex-wrap:wrap;
  padding:8px; border:1px dashed #c8c8c8; border-radius:10px; background:#fafafa;
}
#inventoryBody .miscForm input[type="text"]{ flex:1; min-width:140px; }
#inventoryBody .miscForm input[type="number"]{ width:110px; }


/* --- Misc items: make rows perfectly match other inventory rows --- */
#inventoryBody #miscList{ gap:0 !important; }
#inventoryBody #miscList .invRow{ margin-top:8px; } /* same visual spacing as other inv rows */
#inventoryBody #miscList .invRow:first-child{ margin-top:0; }

#inventoryBody .invDel{
  width:22px !important;
  height:22px !important;
  line-height:20px !important;
  padding:0 !important;
  border-radius:999px !important;
  font-size:16px !important;
  display:inline-flex !important;
  align-items:center !important;
  justify-content:center !important;
}
#inventoryBody .invPrice{
  min-width:84px;
  text-align:right;
  font-variant-numeric:tabular-nums;
}


/* --- Add Misc form sizing tweaks --- */
#inventoryBody #miscForm input#miscDesc{
  flex: 2;
  min-width: 220px;
}
#inventoryBody #miscForm input#miscPrice{
  width: 80px;
}


/* --- Inline edit for Misc inventory items --- */
#inventoryBody .invRow.editing{
  background:#f7f9ff;
}
#inventoryBody .invEditInput{
  font-size:14px;
  padding:4px 6px;
  border:1px solid #999;
  border-radius:6px;
}
#inventoryBody .invEditPrice{
  width:90px;
  text-align:right;
}


/* --- Match input height to Add button --- */
#inventoryBody #miscForm button,
#inventoryBody #miscForm input,
#inventoryBody .invEditInput{
  height:32px;
  line-height:30px;
}


/* --- Center Add / Cancel button text perfectly --- */
#inventoryBody #miscForm button{
  display:inline-flex;
  align-items:center;
  justify-content:center;
  height:32px;
  line-height:32px;
}


/* --- Mobile drawing: prevent page pan/zoom while interacting --- */
html, body {
  overscroll-behavior: none;
  touch-action: none;
}


/* --- Removal UI sizing --- */
#inventoryBody #removalForm input#removalFt{
  width: 90px;
}


#inventoryBody #wedgesForm input#wedgesFt{
  width: 90px;
}


/* --- Inventory price alignment --- */
#inventoryPanel .invPrice{
  display:inline-block;
  min-width: 84px;
  text-align: right;
}


/* Inventory: hide downspout prices in-row (2 columns: label + qty only) */
#row2x3 .invPrice, #row3x4 .invPrice,
#inv2x3Price, #inv3x4Price {
  display: none !important;
}


/* Inventory action buttons: force 3 equal buttons per row */
.invActions{
  display:grid !important;
  grid-template-columns: repeat(3, 1fr) !important;
  gap:8px !important;
  margin-top:8px;
}
.invActions button{
  width:100% !important;
  height:36px;
  padding:6px 4px;
  box-sizing:border-box;
}


/* Inventory: Misc/Removal/Wedges buttons evenly spaced (3 per row) */
.invActions{
  display:grid;
  grid-template-columns: repeat(3, 1fr);
  gap:8px;
  margin-top:8px;
}
.invActions button{
  width:100%;
  height:36px;
  padding:6px 4px;
  box-sizing:border-box;
  text-align:center;
}
.invForms{
  display:flex;
  flex-direction:column;
  gap:8px;
  margin-top:8px;
}



/* Match Removal/Wedges ft inputs height to Add buttons */
#removalFt, #wedgesFt {
  height: 30px;
  padding: 4px 6px;
  box-sizing: border-box;
  font-size: 14px;
}


/* Floating zoom controls */
#zoom-controls{
  position:fixed;
  right:12px;
  bottom:12px;
  z-index:30000;
  display:flex;
  flex-direction:column;
  gap:8px;
}
#zoom-controls button{
  width:44px;
  height:44px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,0.25);
  background:#fff;
  cursor:pointer;
  font-size:18px;
  line-height:1;
  box-shadow:0 2px 8px rgba(0,0,0,0.15);
}
#zoom-controls button:active{
  transform:translateY(1px);
}


/* Floating zoom controls */
#zoom-controls{
  position:fixed;
  right:12px;
  bottom:12px;
  z-index:30000;
  display:flex;
  flex-direction:column;
  gap:8px;
}
#zoom-controls button{
  width:44px;
  height:44px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,0.25);
  background:#fff;
  cursor:pointer;
  font-size:18px;
  line-height:1;
  box-shadow:0 2px 8px rgba(0,0,0,0.15);
}
#zoom-controls button:active{ transform:translateY(1px); }


/* Floating center toolbar (visual only) */
#floatingToolbarWrap{
  position:fixed;
  left:50%;
  bottom:14px;
  transform:translateX(-50%);
  z-index:35000;
  pointer-events:none; /* only the bar itself should receive clicks */
}
#floatingToolbar{
  pointer-events:auto;
  display:flex;
  align-items:center;
  gap:10px;
  padding:10px 12px;
  border-radius:16px;
  background:rgba(235, 235, 235, 0.95);
  border:1px solid rgba(0,0,0,0.10);
  box-shadow:0 6px 18px rgba(0,0,0,0.18);
  backdrop-filter:saturate(140%) blur(6px);
}
#floatingToolbar .ft-btn{
  width:42px;
  height:42px;
  border-radius:14px;
  border:1px solid rgba(0,0,0,0.18);
  background:rgba(255,255,255,0.95);
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:18px;
  line-height:1;
  cursor:pointer; /* visual only for now */
  user-select:none;
}
#floatingToolbar .ft-sep{
  width:1px;
  height:28px;
  background:rgba(0,0,0,0.15);
  margin:0 2px;
}
#floatingToolbar .ft-btn:active{
  transform:translateY(0); /* no behavior change */
}


#floatingToolbar .ft-btn img{
  max-width:22px;
  max-height:22px;
  width:auto;
  height:auto;
  object-fit:contain;
  pointer-events:none;
}


/* Legacy top toolbar visibility */
body:not(.showTopToolbar) #toolbar{ display:none; }


/* Floating toolbar active state */
#floatingToolbar .ft-btn.active{
  background:#cfd6dc;
  border-color:#7a8794;
  box-shadow:inset 0 0 0 2px rgba(0,0,0,0.08);
}


/* Hide Text tool in legacy left toolbar (use floating toolbar instead) */
#tool-text{ display:none !important; }


/* Right panel close button */
.panelHeader{ display:flex; align-items:center; justify-content:space-between; gap:8px; }
.panelCloseBtn{
  border:1px solid rgba(0,0,0,0.2);
  background:rgba(255,255,255,0.9);
  width:28px; height:28px;
  border-radius:8px;
  cursor:pointer;
  font-size:18px;
  line-height:1;
}
.panelCloseBtn:active{ transform:translateY(1px); }


/* Right panel headers with close buttons */
#inventoryPanelHeader, #infoPanelHeader, #settingsPanelHeader, #projectPanelHeader{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:8px;
}


/* --- Info Tabs Overlay --- */
#infoTabsOverlay{
  position:fixed;
  top:0;
  right:0;
  width:clamp(300px, 34vw, 80vw);
  max-width:80vw;
  box-sizing:border-box;
  padding:10px 12px;
  background:#e6e6e6;
  border-left:1px solid #bbb;
  box-shadow:-6px 0 18px rgba(0,0,0,0.12);
  display:none;
  z-index:23000;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
#infoTabsOverlay.show{ display:flex; }
#infoTabsOverlay .tabBar{ display:flex; gap:8px; flex:1; }
#infoTabsOverlay .tabBtn{
  padding:8px 10px;
  border-radius:12px;
  border:1px solid rgba(0,0,0,0.16);
  background:rgba(255,255,255,0.9);
  cursor:pointer;
  font-size:13px;
  font-weight:600;
}
#infoTabsOverlay .tabBtn.active{
  background:#cfd6dc;
  border-color:#7a8794;
  box-shadow:inset 0 0 0 2px rgba(0,0,0,0.08);
}


/* When info tabs are shown, push right panels down so headers aren't covered */
body.infoTabsShown #infoPanel,
body.infoTabsShown #projectPanel,
body.infoTabsShown #inventoryPanel,
body.infoTabsShown #upgradesPanel,
body.infoTabsShown #settingsPanel{
  top:52px;
  height:calc(100vh - 52px);
}


/* Keep overlay and right panels perfectly aligned */
#infoTabsOverlay, #infoPanel, #projectPanel, #inventoryPanel, #upgradesPanel, #settingsPanel{ box-sizing:border-box; }


/* --- Active parent tool = black (safe, does not affect sub-options) --- */
#leftPanel button.tool-btn.active{
  background:#111;
  color:#fff;
  border-color:#000;
  box-shadow:inset 0 0 0 1px rgba(255,255,255,0.15);
}


/* --- Left panel separators: modern --- */
#leftPanel .lp-sep{
  height:1px;
  margin:10px 2px;
  border-radius:999px;
  background:linear-gradient(to right,
    rgba(0,0,0,0.00),
    rgba(0,0,0,0.16),
    rgba(0,0,0,0.00)
  );
  box-shadow:0 1px 0 rgba(255,255,255,0.45);
}
/* --- Floating total $ overlay (top-right) --- */
#floatingTotal{
  position:fixed;
  top:10px;
  right:10px;
  z-index:18000;
  background:rgba(0,0,0,0.78);
  color:#fff;
  padding:8px 12px;
  border-radius:14px;
  font-weight:800;
  font-size:16px;
  letter-spacing:0.02em;
  box-shadow:0 6px 18px rgba(0,0,0,0.25);
  pointer-events:auto;
  cursor:pointer;
  user-select:none;
}
#floatingTotal:active{ transform:scale(0.98); }


/* Ensure right panels overlay floating total */
#inventoryPanel,
#infoPanel,
#projectPanel,
#settingsPanel{
  z-index:22000;
}


/* --- Accessories UI (bigger text + spinner stepper) --- */
#accessoriesForm .accTitle{
  font-weight:800;
  font-size:14px;
}
#accessoriesForm .accRow{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:10px;
}
#accessoriesForm .accLabel{
  flex:1;
  font-size:14px;
  color:#222;
}
#accessoriesForm .accStepper{
  display:flex;
  align-items:center;
  gap:6px;
}
#accessoriesForm .accStepBtn{
  width:30px;
  height:30px;
  border-radius:10px;
  border:1px solid rgba(0,0,0,0.18);
  background:#fff;
  cursor:pointer;
  font-size:18px;
  line-height:1;
  display:inline-flex;
  align-items:center;
  justify-content:center;
}
#accessoriesForm .accQty{
  width:46px;
  height:30px;
  border-radius:10px;
  border:1px solid rgba(0,0,0,0.18);
  background:#fff;
  text-align:center;
  font-size:14px;
  padding:0 6px;
  box-sizing:border-box;
  font-variant-numeric: tabular-nums;
}
/* Hide native number spinners where possible */
#accessoriesForm input[type=number]::-webkit-outer-spin-button,
#accessoriesForm input[type=number]::-webkit-inner-spin-button {
  -webkit-appearance: none;
  margin: 0;
}
#accessoriesForm input[type=number] { -moz-appearance:textfield; }





/* --- Project Panel: Choose User (safe, UI-only) --- */
#projectPanelBody .userPick{
  display:flex;
  gap:10px;
  align-items:center;
}
#projectPanelBody .userBtn{
  width:68px;
  height:68px;
  padding:0;
  border-radius:999px;
  border:2px solid rgba(0,0,0,0.18);
  background:#fff;
  cursor:pointer;
  display:inline-flex;
  align-items:center;
  justify-content:center;
  overflow:hidden;
}
#projectPanelBody .userBtn img{
  width:100%;
  height:100%;
  object-fit:cover;
}
#projectPanelBody .userBtn.active{
  outline:3px solid orange;
}



/* --- Project Info: Colors row (50/50, full-width selects) --- */
#projectPanelBody #projectColorsRow .piColorsRow{
  display:flex;
  gap:12px;
  width:100%;
  align-items:flex-end;
}
#projectPanelBody #projectColorsRow .piColorCol{
  flex:0 0 calc(50% - 6px);
  min-width:0;
}
#projectPanelBody #projectColorsRow .piMiniLabel{
  font-size:11px;
  color:#333;
  display:block;
  margin-bottom:4px;
}
#projectPanelBody #projectColorsRow select{
  width:100% !important;
  min-width:0 !important;
  box-sizing:border-box;
  padding:6px 10px;
  border:1px solid #bbb;
  border-radius:8px;
  font-size:14px;
  background:#fff;
}



/* --- Info Tabs: Settings tab icon (inherits pill button styling) --- */
#itSettings img{
  width:16px;
  height:16px;
  display:block;
  opacity:0.9;
  pointer-events:none;
}
.itTabBtn.active#itSettings img{
  opacity:1;
}


/* --- Info Tabs: force Settings tab to match pill styling --- */
#itSettings.itTabBtn{
  border-radius:999px !important;
  background:#fff !important;
  border:1px solid #bbb !important;
  padding:6px 12px !important;
}
#itSettings.itTabBtn.active{
  background:#e6e6e6 !important;
}


/* --- Settings: Current Price List --- */
.settingsSection{
  border:1px solid #cfcfcf;
  background:#fff;
  border-radius:12px;
  padding:10px;
  margin-top:10px;
}
.settingsSectionTitle{
  font-weight:700;
  margin-bottom:8px;
}
.priceListContainer table{
  width:100%;
  border-collapse:collapse;
  font-size:13px;
}
.priceListContainer th,
.priceListContainer td{
  padding:6px 8px;
  border-bottom:1px solid #eee;
  text-align:left;
}
.priceListContainer th{
  background:#f6f6f6;
  border-bottom:1px solid #ddd;
}
.priceListContainer td:last-child,
.priceListContainer th:last-child{
  text-align:right;
  white-space:nowrap;
}
.priceListNote{
  margin-top:6px;
  font-size:11px;
  color:#555;
}


/* Inventory panel: selected button highlight (one at a time) */
#inventoryBody .invActive{
  background:#444 !important;
  color:#fff !important;
  border-color:#333 !important;
}


/* --- Removal / Wedges / Drip Strip: label + consistent sizing --- */
#inventoryBody #removalForm,
#inventoryBody #wedgesForm,
#inventoryBody #dripStripForm{
  display:flex;
  flex-wrap:wrap;
  align-items:center;
  gap:6px;
}

#inventoryBody .invFtLabel{
  min-width:86px;
  font-weight:600;
  font-size:13px;
}

#inventoryBody #removalForm input,
#inventoryBody #wedgesForm input,
#inventoryBody #dripStripForm input{
  height:32px;
  width:90px;
  box-sizing:border-box;
  font-size:13px;
  padding:6px 8px;
}

#inventoryBody #removalForm button,
#inventoryBody #wedgesForm button,
#inventoryBody #dripStripForm button{
  height:32px;
  min-width:56px;
  box-sizing:border-box;
  font-size:13px;
  padding:0 10px;
  display:inline-flex;
  align-items:center;
  justify-content:center;
}


/* Inventory form section titles */
#inventoryBody .invSectionTitle{
  font-size:12px;
  font-weight:700;
  letter-spacing:0.5px;
  margin:10px 0 4px 0;
  opacity:0.8;
}

/* ===== Upgrades card animation ===== */
.upgradeCard--pressed{
  transform:scale(0.985);
}
.upgradeCard--selected{
  border-color:#1bbf5c !important;
  box-shadow:0 8px 22px rgba(0,0,0,0.12) !important;
}

/* Upgrades amount flip (Price ‚Üî Accepted) */
.upgAmtWrap{display:inline-block; position:relative; min-width:86px; height:18px;}
.upgAmtWrap > span{position:absolute; right:0; top:0; transition:opacity .18s ease, transform .18s ease;}
.upgAmtWrap[data-state="price"] .upgAmtPrice{opacity:1; transform:translateY(0);}
.upgAmtWrap[data-state="price"] .upgAmtAccepted{opacity:0; transform:translateY(6px);}
.upgAmtWrap[data-state="accepted"] .upgAmtPrice{opacity:0; transform:translateY(-6px);}
.upgAmtWrap[data-state="accepted"] .upgAmtAccepted{opacity:1; transform:translateY(0);}

/* Estimate Preview + PDF */
.modalOverlay{
  position:fixed; inset:0;
  background:rgba(0,0,0,.25);
  display:flex; align-items:center; justify-content:center;
  z-index:9999;
}
.modalOverlay.hidden{ display:none; }
.estimateModal{
  width:min(980px, 96vw);
  height:min(92vh, 920px);
  background:#fff;
  border-radius:14px;
  box-shadow:0 20px 60px rgba(0,0,0,.25);
  display:flex; flex-direction:column;
  overflow:hidden;
}
.estimateTopBar{
  background:#5fb2c7;
  color:#fff;
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
  padding:12px 14px;
}
.estTitle{ font-weight:700; }
.estBtn{
  border:none;
  background:rgba(255,255,255,.18);
  color:#fff;
  padding:8px 10px;
  border-radius:10px;
  cursor:pointer;
  font-weight:600;
}
.estBtn:hover{ background:rgba(255,255,255,.28); }
.estBtn.primary{ background:#e15b4f; }
.estBtn.primary:hover{ background:#d24f44; }
.estimateContent{ padding:14px; overflow:auto; }
.estSheet{ border:1px solid #e6e6e6; border-radius:10px; overflow:hidden; }
.estSheetHeader{ background:#5fb2c7; color:#fff; padding:14px 16px; font-size:20px; font-weight:800; }
.estSheetBody{ display:grid; grid-template-columns: 1fr 1fr; gap:14px; padding:14px; }
.estCanvasBox{ border:1px solid #e6e6e6; border-radius:10px; padding:10px; display:flex; align-items:center; justify-content:center; min-height:260px; }
.estCanvasBox img{ max-width:100%; height:auto; }
.estTextBox{ border:1px dashed #9ad1dd; border-radius:10px; padding:12px; font-size:12px; line-height:1.45; white-space:pre-wrap; }
.estTableWrap{ padding:0 14px 14px; }
.estTable{ width:100%; border-collapse:collapse; font-size:12px; }
.estTable th{ background:#5fb2c7; color:#fff; text-align:left; padding:8px; }
.estTable td{ border:1px solid #d9d9d9; padding:8px; }
.estTotals{ display:flex; justify-content:flex-end; gap:18px; padding:12px 14px 16px; font-size:13px; font-weight:700; }
@media print{ body{ overflow:visible !important; } }
/* PDF Template (Letter) */
.pdfRoot{
  width: 8.5in;
  background:#fff;
  color:#111;
  font-family: Arial, sans-serif;
  padding: 0.5in;
  box-sizing:border-box;
}
.pdfHeader{
  display:flex;
  justify-content:space-between;
  align-items:flex-end;
  gap:12px;
  margin-bottom:12px;
  padding-bottom:10px;
  border-bottom:2px solid #5fb2c7;
}
.pdfHeader .h1{
  font-size:20px;
  font-weight:800;
}
.pdfHeader .meta{
  font-size:11px;
  text-align:right;
  white-space:pre-line;
  color:#333;
}
.pdfGrid{
  display:grid;
  grid-template-columns: 1fr 1fr;
  gap:14px;
  margin-bottom:12px;
}
.pdfCanvasBox{
  border:1px solid #e6e6e6;
  border-radius:10px;
  padding:10px;
  min-height:280px;
  display:flex;
  align-items:center;
  justify-content:center;
}
.pdfCanvasBox img{ max-width:100%; height:auto; }
.pdfRight{
  display:flex;
  flex-direction:column;
  gap:10px;
}
.pdfSectionTitle{
  font-weight:800;
  font-size:13px;
  margin:0 0 6px 0;
}
.pdfUpgrades{
  border:1px solid #e6e6e6;
  border-radius:10px;
  padding:10px;
}
.pdfUpgrades ul{
  margin:0;
  padding-left:18px;
  font-size:12px;
}
.pdfUpgrades li{
  margin:4px 0;
  display:flex;
  justify-content:space-between;
  gap:10px;
}
.pdfProposal{
  border:1px solid #e6e6e6;
  border-radius:10px;
  padding:10px;
  font-size:12px;
  line-height:1.45;
  white-space:pre-wrap;
  min-height:120px;
}
.pdfTotals{
  display:flex;
  justify-content:flex-end;
  gap:16px;
  font-size:12px;
  font-weight:700;
  margin-top:10px;
}
.pdfNoBreak{ break-inside: avoid; page-break-inside: avoid; }
</style>
</head>
<body>

<div id="toolbar">
  <!-- Row 1: tools -->
  <div class="toolbar-row">
<strong>Gutter Estimator v12.5.2</strong>

    <!-- moved to left panel: tool-line -->
    <button id="tool-2x3" class="tool-btn" onclick="setTool('2x3')">2x3</button>
    <button id="tool-3x4" class="tool-btn" onclick="setTool('3x4')">3x4</button>
    <!-- moved to left panel: tool-door -->
    <!-- moved to left panel: tool-text -->
    <button id="tool-select" class="tool-btn" onclick="setTool('select')">‚ñ≤</button>
    <button id="tool-eraser" class="tool-btn" onclick="setTool('eraser')">üóëÔ∏è</button>
<!-- These are now hidden by app.js (but still here if you ever want them back) -->
    <span id="scaleLabel">Scale:</span>
    <select id="scaleSelect" onchange="setScale(this.value)">
      <option value="40">40 ft</option>
      <option value="60">60 ft</option>
      <option value="80" selected>80 ft</option>
      <option value="100">100 ft</option>
    </select>

    <span id="labelSizeLabel">Label Size:</span>
    <input id="labelSizeSlider" type="range" min="10" max="40" value="25" oninput="setLabelSize(this.value)">

    <!-- merged from Row 2 -->
<button onclick="undo()">Undo</button>
    <button onclick="redo()">Redo</button>
    <input id="projectFileInput" type="file" accept="application/json,.json" style="display:none" onchange="handleProjectFileSelected(this.files[0]); this.value='';">
</div>

  <!-- Row 2: file + export -->
  
</div>


<!-- Left Tool Panel -->
<div id="leftPanel">

  <button id="tool-line" class="tool-btn active" onclick="setTool('line')">Gutter</button>
  <button id="tool-splash" class="tool-btn" onclick="setTool('splash')">Splash Guard</button>
  <!-- Downspout button + nested options are injected by JS (tool-downspout) -->
  <!-- Covers button + nested options are injected by JS (tool-covers) -->

  <button id="tool-door" class="tool-btn" onclick="setTool('door')">Door</button>
  <button id="tool-text" class="tool-btn" onclick="setTool('text')">Text</button>

  <div class="lp-sep"></div>
  <button onclick="openInfoTabs('customer')">Customer</button>
  <button onclick="openInfoTabs('project')">Project</button>
  <button onclick="openInfoTabs('inventory')">Inventory</button>
  <button id="btnUpgrades" onclick="openInfoTabs('upgrades')">Upgrades</button>
<div class="lp-spacer"></div>

  <button onclick="toggleSettingsPanel()">Settings</button>

  <div class="lp-sep"></div>
  <button onclick="openEstimatePreview()">Preview</button>
  <button onclick="saveProjectJSON()">Save</button>
  <button onclick="triggerLoadProject()">Load</button>

</div>

<!-- Inventory Tracker (floating, top-right) -->
<div id="inventoryPanel" class="">
  <div id="inventoryHeader" style="display:flex;align-items:center;gap:8px;">
    <span>Inventory</span>
    <span id="inventoryHeaderTotal" style="margin-left:auto;font-weight:700;">$0.00</span>
</div>
<div id="inventoryBody">
<div id="invEmpty" class="invEmpty" style="display:none;">No inventory yet</div>

  <div class="invRow" id="rowTotalGutter">
    <span class="label">Total Gutter</span><span class="value" id="invTotalGutter">0'</span>
  </div>
  <div class="invRow" id="row2x3">
    <span class="label">2x3</span>
    <div style="display:flex;gap:8px;align-items:center;">
      <span class="invPrice" id="inv2x3Price">$0.00</span>
      <span class="value" id="inv2x3">0</span>
    </div>
  </div>
  <div class="invRow" id="row3x4">
    <span class="label">3x4</span>
    <div style="display:flex;gap:8px;align-items:center;">
      <span class="invPrice" id="inv3x4Price">$0.00</span>
      <span class="value" id="inv3x4">0</span>
    </div>
  </div>
  <div class="invRow" id="rowBoxMiter">
    <span class="label">Box Miter</span><span class="value" id="invBoxMiter">0</span>
  </div>
  <div class="invRow" id="rowStripMiter">
    <span class="label">Strip Miter</span><span class="value" id="invStripMiter">0</span>
  </div>
</div>

<div id="inventoryFooter" style="padding:10px 10px 12px 10px;border-top:1px solid #cfcfcf;">
  <div class="invRow" id="rowTotalPrice" style="margin:0;">
    <span class="label" style="font-weight:700;">Total Price</span>
    <span class="invPrice" id="invTotalPrice" style="font-weight:700;">$0.00</span>
  </div>
</div>
</div>

<canvas id="canvas"></canvas>

<!-- All app logic lives here -->
<script>
// Gutter Estimator v12.5.2 ‚Äî logic filenge: Downspout tool becomes a single button + dropdown (2x3/3x4). Inventory tracks Upper/Lower gutter totals separately.

const APP_VERSION = "v12.5.2";

// Pricing (used for inventory totals)
const DS_PRICE_2X3 = 80;
const DS_PRICE_3X4 = 0; // set this if you want 3x4 priced

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");


// Mobile safety: prevent the browser from canceling long drags (page scroll/gesture)
document.addEventListener("touchmove", (e) => {
  if (isPrimaryPointerDown) e.preventDefault(); // lock page scroll while drawing
}, { passive: false });
let feetAcross = 80;   // can become non-integer after fit; kept in sync so resize doesn't break zoom
let gridSize = 1;
let labelSize = 25;
let showLabels = true; // toggle gutter length + DS labels
let customerInfo = { firstName:"", lastName:"", address:"", city:"", zip:"", phone:"", email:"" };
let projectInfo = { scheduleFor: "", proposal: "" };

let lines = [];
let nextLineId = 1; // unique ids for gutter segments (stabilizes undo/redo + attachments)

let splashGuards = []; // drawable splash guard segments
let nextSplashId = 1;
let downspouts = [];
let texts = [];
let doors = [];
let miscItems = []; // {desc:string, price:number}

let corners = [];

let undoStack = [];
let redoStack = [];

let tool = "line";
let currentColor = "black";

// Dropdown colors (Gutter + Downspout)
const COLOR_OPTIONS = [
  "White",
  "Almond",
  "Black",
  "Eggshell",
  "Charcoal",
  "Stone Clay",
  "Grecian Green",
  "Musket",
  "Royal",
  "Barn Red",
  "Terra Bronze",
  "Gray",
  "Wicker",
  "30¬∞ White",
  "TBD"
];

// Approximate screen colors (you can tweak anytime)
const COLOR_MAP = {
  "White": "#ffffff",
  "Almond": "#efdecd",
  "Black": "#000000",
  "Eggshell": "#f0ead6",
  "Charcoal": "#36454f",
  "Stone Clay": "#b2a59b",
  "Grecian Green": "#4f7942",
  "Musket": "#8a8f8b",
  "Royal": "#4169e1",
  "Barn Red": "#7c0a02",
  "Terra Bronze": "#8b5a2b",
  "Gray": "#808080",
  "Wicker": "#c3b091",
  "30¬∞ White": "#f8f8f8",
  "TBD": "#ff00ff"
};

let gutterColorName = "Please Select";
let downspoutColorName = "Please Select";

function colorValue(name) {
  return COLOR_MAP[name] || "#000000";
}

function setGutterColor(name) {
  gutterColorName = name;
}
function setDownspoutColor(name) {
  downspoutColorName = name;
}


// Gutter level (used only for tool==="line")
let gutterLevel = "lower"; // "lower" | "upper"

// Downspout type (used only for tool==="downspout")
let downspoutType = "2x3"; // "2x3" | "3x4"

let drawingLine = null;
let drawingSplash = null;
let draggingPoint = null;
let draggingDownspout = null;
let draggingText = null;
let selectedTextObj = null; // selected text for resize handle
let draggingTextResize = null; // {obj, anchorX, anchorY, startDist, startSize}

let draggingDoor = null;
let draggingLineLabel = null; // dragging gutter length label
let draggingDsLabel = null; // dragging downspout label
let dsClickStart = { x: 0, y: 0 };
let dsClickMoved = false;

let doorClickStart = { x: 0, y: 0 };
let doorClickMoved = false;
let dsLabelDragAxis = null; // 'x' | 'y'
let dsLabelDragStart = { x: 0, y: 0 };
let labelDragAxis = null; // 'x' | 'y' lock decided on first move
let labelDragStart = { x: 0, y: 0 };

let textOffset = { x: 0, y: 0 };
let doorOffset = { x: 0, y: 0 };

let panX = 0, panY = 0;
let panning = false;
let panStart = { x: 0, y: 0 };

let hoverSelect = null;
let hoverDelete = null;
let hoverLineLabel = null; // gutter length label hover (selector tool)


let SNAP_RADIUS = 10;
let DS_RADIUS = 9;

// Downspout inventory quantity (1-4) -> circled digit symbol
function dsQtyDefaultForLine(line) {
  const lvl = (line && line.level === "upper") ? "upper" : "lower";
  return (lvl === "upper") ? 2 : 1;
}
function dsQtyToSymbol(q) {
  const n = Math.max(1, Math.min(4, Math.round(q || 1)));
  return ["¬π","¬≤","¬≥","‚Å¥"][n - 1];
}
function cycleDsQty(q) {
  const n = Math.max(1, Math.min(4, Math.round(q || 1)));
  return (n >= 4) ? 1 : (n + 1);
}
function drawDsLabel(x, y, supSymbol) {
  // Draw DS with a superscript-style circled quantity (‚ë†-‚ë£) without overlap, centered as a unit.
  ctx.save();

  const baseFont = labelSize + "px Arial";
  const supFont  = (labelSize * 0.90) + "px Arial"; // same family, slightly smaller
  const gap = Math.max(1, labelSize * 0.06);
  const raise = labelSize * 0.38;

  ctx.textBaseline = "alphabetic";

  // Measure widths (need to set font before measure)
  ctx.font = baseFont;
  const wDS = ctx.measureText("DS").width;

  ctx.font = supFont;
  const wSup = ctx.measureText(supSymbol).width;

  const total = wDS + gap + wSup;
  const startX = x - total / 2;

  // Draw "DS"
  ctx.font = baseFont;
  ctx.textAlign = "left";
  ctx.fillText("DS", startX, y);

  // Draw superscript symbol
  ctx.font = supFont;
  ctx.fillText(supSymbol, startX + wDS + gap, y - raise);

  ctx.restore();
}



// Hide advanced controls from toolbar (keeps variables working)
function hideToolbarControls() {
  // Hide advanced controls if they exist (safe no-ops when missing)
  const ids = [
    "labelSizeSlider",
    "scaleSelect",
    "labelSize", "labelSizeInput", "labelSizeSlider",
    "scale", "scaleInput", "scaleSlider",
    "feetAcross", "feetAcrossInput",
    "gridSize", "gridSizeInput"
  ];
  ids.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });

  // Hide any text labels next to them if you kept them in the DOM
  const labelIds = ["scaleLabel", "labelSizeLabel"];
  labelIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });

  // Also hide common wrapper rows if you used them
  const wrappers = ["labelRow", "scaleRow", "advancedRow"];
  wrappers.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
}


// Inventory UI refs (from index.html)
const inventoryPanel = document.getElementById("inventoryPanel");

// Show inventory by default
if (inventoryPanel) inventoryPanel.classList.remove("hidden");
  inventoryPanel.classList.remove("open");
const invEmptyEl = document.getElementById("invEmpty");

const rowTotalGutter = document.getElementById("rowTotalGutter"); // we will hide & replace with upper/lower rows
const row2x3 = document.getElementById("row2x3");
const row3x4 = document.getElementById("row3x4");
const rowCorners = document.getElementById("rowCorners");
const rowBoxMiter = document.getElementById("rowBoxMiter");
const rowStripMiter = document.getElementById("rowStripMiter");

const invTotalGutterEl = document.getElementById("invTotalGutter");
const inv2x3El = document.getElementById("inv2x3");
const inv3x4El = document.getElementById("inv3x4");
const invCornersEl = document.getElementById("invCorners");
const invBoxMiterEl = document.getElementById("invBoxMiter");
const invStripMiterEl = document.getElementById("invStripMiter");

/* ---------- VERSION LABEL (no index.html edits) ---------- */
function applyVersionLabel() {
  try {
    document.title = "Gutter Estimator " + APP_VERSION;
    const toolbarStrong = document.querySelector("#toolbar .toolbar-row strong");
    if (toolbarStrong) toolbarStrong.textContent = "Gutter Estimator " + APP_VERSION;
  } catch (_) {}
}
applyVersionLabel();

/* ---------- TOOLBAR UI INJECTION (GUTTER LEVEL + DOWNSPOUT DROPDOWN) ---------- */
function stylePill(el) {
  el.style.display = "inline-flex";
  el.style.alignItems = "center";
  el.style.gap = "6px";
  el.style.marginLeft = "6px";
  el.style.padding = "4px 8px";
  el.style.border = "1px solid rgba(0,0,0,0.18)";
  el.style.borderRadius = "10px";
  el.style.background = "rgba(255,255,255,0.65)";
}

function styleSelect(sel) {
  sel.style.padding = "2px 6px";
  sel.style.borderRadius = "8px";
  sel.style.border = "1px solid rgba(0,0,0,0.18)";
  sel.style.background = "rgba(255,255,255,0.9)";
  sel.style.fontSize = "12px";
  sel.style.fontWeight = "700";
}

function styleMiniLabel(span) {
  span.style.fontSize = "12px";
  span.style.fontWeight = "700";
  span.style.color = "#222";
}

let gutterLevelWrap = null;
let gutterLevelSelect = null;

let dsWrap = null;
let dsSelect = null;

let openToolGroup = ""; // "gutter" | "downspout" | "covers" | ""

function stylePanelPill(wrap, sel) {
  // Keep pill inside the left panel width
  if (!wrap) return;
  wrap.style.width = "calc(100% - 12px)";
  wrap.style.boxSizing = "border-box";
  wrap.style.display = "none"; // default closed
  wrap.style.marginLeft = "0";
  wrap.style.marginRight = "0";
  wrap.style.justifyContent = "space-between";
  if (sel) {
    sel.style.flex = "1";
    sel.style.minWidth = "0";
    sel.style.maxWidth = "100%";
  }
}

function closeAllOptionGroups() {
  openToolGroup = "";
  if (gutterLevelWrap) gutterLevelWrap.style.display = "none";
  if (dsWrap) dsWrap.style.display = "none";
  if (coversWrap) coversWrap.style.display = "none";
}

function toggleOptionGroup(group) {
  if (openToolGroup === group) {
    closeAllOptionGroups();
    return;
  }
  openToolGroup = group;
  if (gutterLevelWrap) gutterLevelWrap.style.display = (group === "gutter") ? "inline-flex" : "none";
  if (dsWrap) dsWrap.style.display = (group === "downspout") ? "inline-flex" : "none";
  if (coversWrap) coversWrap.style.display = (group === "covers") ? "inline-flex" : "none";
}

let coversWrap = null;
let coversSelect = null;
let coverType = "";


// Covers (Step 1): data only (no UI/drawing/mouse changes)
let coverTRexLineIds = new Set(); // Set<lineId>
let coverDoubleProLineIds = new Set(); // Set<lineId>
 
// PVC selections (covers-like)
let pvcWedgesLineIds = new Set(); // Set<lineId>
let pvcAddBoardLineIds = new Set(); // Set<lineId>
let hoverCoverLineIds = null; // Set<lineId> (hover preview)

// PVC (covers-like) Step 1&2: mode + hover only (no apply/inventory yet)
let pvcType = "wedges"; // "wedges" | "addaboard"
let hoverPVCLineIds = null; // Set<lineId> (hover preview)

function enforceExclusiveCovers() {
  // Ensure a line cannot be both T-Rex and Double PRO at once.
  if (!coverTRexLineIds || !coverDoubleProLineIds) return;
  for (const id of Array.from(coverTRexLineIds)) {
    if (coverDoubleProLineIds.has(id)) coverDoubleProLineIds.delete(id);
  }
}

let rowTRex = null;
let invTRexEl = null;
let rowDoublePro = null;
let invDoubleProEl = null;

let rowSplashGuard = null;
let invSplashGuardEl = null;
function buildGutterLevelUI() {
  const row = document.querySelector("#toolbar .toolbar-row");
  const gutterBtn = document.getElementById("tool-line");
  if (!row || !gutterBtn) return;

  if (document.getElementById("gutterLevelWrap")) return;

  gutterLevelWrap = document.createElement("span");
  gutterLevelWrap.id = "gutterLevelWrap";
  stylePill(gutterLevelWrap);

  const label = document.createElement("span");
  label.textContent = "Gutter:";
  styleMiniLabel(label);

  gutterLevelSelect = document.createElement("select");
  gutterLevelSelect.id = "gutterLevelSelect";
  styleSelect(gutterLevelSelect);
  gutterLevelSelect.innerHTML = `
    <option value="lower">Lower</option>
    <option value="upper">Upper</option>
  `;
  gutterLevelSelect.value = gutterLevel;
  gutterLevelSelect.addEventListener("change", () => {
    gutterLevel = gutterLevelSelect.value === "upper" ? "upper" : "lower";
  });

  gutterLevelWrap.appendChild(label);
  gutterLevelWrap.appendChild(gutterLevelSelect);

  // Make gutter button expand/collapse its options
  gutterBtn.onclick = () => { setTool("line"); toggleOptionGroup("gutter"); };

  gutterBtn.insertAdjacentElement("afterend", gutterLevelWrap);
  stylePanelPill(gutterLevelWrap, gutterLevelSelect);

  updateInjectedVisibility();
}

function buildDownspoutUI() {
  const row = document.querySelector("#toolbar .toolbar-row");
  if (!row) return;

  // Hide the old separate DS tool buttons (2x3 and 3x4) without touching index.html
  const old2 = document.getElementById("tool-2x3");
  const old3 = document.getElementById("tool-3x4");
  if (old2) old2.style.display = "none";
  if (old3) old3.style.display = "none";

  // If we already injected, stop
  if (document.getElementById("tool-downspout")) return;

  // Insert the new DS button where the old ones were (near gutter button)
  const gutterBtn = document.getElementById("tool-line");
  if (!gutterBtn) return;

  const dsBtn = document.createElement("button");
  dsBtn.id = "tool-downspout";
  dsBtn.id = "tool-downspout";
  dsBtn.className = "tool-btn";
  dsBtn.textContent = "Downspout";
  dsBtn.onclick = () => { setTool("downspout"); toggleOptionGroup("downspout"); };

  // Insert after gutter-level UI if present; else after gutter button
  const afterEl = document.getElementById("gutterLevelWrap") || gutterBtn;
  afterEl.insertAdjacentElement("afterend", dsBtn);

  // Create dropdown pill
  dsWrap = document.createElement("span");
  dsWrap.id = "dsWrap";
  stylePill(dsWrap);

  const label = document.createElement("span");
  label.textContent = "Type:";
  styleMiniLabel(label);

  dsSelect = document.createElement("select");
  dsSelect.id = "dsSelect";
  styleSelect(dsSelect);
  dsSelect.innerHTML = `
    <option value="2x3">2x3</option>
    <option value="3x4">3x4</option>
  `;
  dsSelect.value = downspoutType;
  dsSelect.addEventListener("change", () => {
    downspoutType = dsSelect.value === "3x4" ? "3x4" : "2x3";
  });

  dsWrap.appendChild(label);
  dsWrap.appendChild(dsSelect);

  dsBtn.insertAdjacentElement("afterend", dsWrap);
  stylePanelPill(dsWrap, dsSelect);

  updateInjectedVisibility();
}


function buildCoversUI() {
  // Create a Covers button + pill dropdown, visually matching Downspout.
  const row = document.querySelector("#toolbar .toolbar-row");
  if (!row) return;

  // If already injected, stop
  if (document.getElementById("tool-covers")) return;

  const dsWrapEl = document.getElementById("dsWrap");
  const dsBtn = document.getElementById("tool-downspout");
  const afterEl = dsWrapEl || dsBtn;
  if (!afterEl) return;

  const cBtn = document.createElement("button");
  cBtn.id = "tool-covers";
  cBtn.id = "tool-covers";
  cBtn.className = "tool-btn";
  cBtn.textContent = "Covers";
  // Placeholder tool selection (no behavior yet)
  cBtn.onclick = () => { setTool("covers"); if (!coverType) { coverType = "T-Rex"; if (coversSelect) coversSelect.value = "T-Rex"; } toggleOptionGroup("covers"); };

  // Create dropdown pill
  coversWrap = document.createElement("span");
  coversWrap.id = "coversWrap";
  stylePill(coversWrap);

  const label = document.createElement("span");
  label.textContent = "Type:";
  styleMiniLabel(label);

  coversSelect = document.createElement("select");
  coversSelect.id = "coversSelect";
  styleSelect(coversSelect);
  coversSelect.innerHTML = `
    <option value="">Please Select</option>
    <option value="T-Rex">T-Rex</option>
    <option value="Double PRO">Double PRO</option>
  `;
  coversSelect.value = coverType || "";

  coversSelect.addEventListener("change", () => {
    coverType = coversSelect.value || "";
    // Placeholder: functionality defined later
  });

  coversWrap.appendChild(label);
  coversWrap.appendChild(coversSelect);

  stylePanelPill(coversWrap, coversSelect);

  // Insert under Downspout (button then pill)
  afterEl.insertAdjacentElement("afterend", cBtn);
  cBtn.insertAdjacentElement("afterend", coversWrap);

  updateInjectedVisibility();
}

function buildPVCUI() {
  // PVC (Steps 1&2): UI state only + hover highlight uses tool==="pvc"
  const lp = document.getElementById("leftPanel");
  if (!lp) return;

  // Prevent duplicate injection
  if (document.getElementById("tool-pvc")) return;

  const coversBtn = document.getElementById("tool-covers");
  const anchor = coversBtn || document.getElementById("tool-downspout") || document.getElementById("tool-line");
  if (!anchor) return;

  const pvcBtn = document.createElement("button");
  pvcBtn.id = "tool-pvc";
  pvcBtn.className = "tool-btn";
  pvcBtn.textContent = "PVC";

  const group = document.createElement("div");
  group.className = "pvcGroup";
  group.style.display = "none";
  group.style.flexDirection = "column";
  group.style.gap = "6px";
  group.style.alignItems = "flex-end";

  function activatePVCTool() {
    // IMPORTANT: do not call setTool("pvc") because it rebuilds/removes .optGroup buttons.
    tool = "pvc";
    try {
      document.querySelectorAll(".tool-btn").forEach(b => b.classList.remove("active"));
      pvcBtn.classList.add("active");
    } catch (_) {}
    if (tool !== "pvc") hoverPVCLineIds = null;

  hoverSelect = null;
  hoverDelete = null;
    hoverLineLabel = null;
    if (typeof redraw === "function") redraw();
  }

  function setPVC(mode) {
    pvcType = (mode === "addaboard") ? "addaboard" : "wedges";
    activatePVCTool();
    group.querySelectorAll("button.pvcOptBtn").forEach(b => b.classList.toggle("active", b.dataset.value === pvcType));
  }

  function makeOpt(label, value) {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "pvcOptBtn";
    b.textContent = label;
    b.dataset.value = value;

    // Match left-panel nested option style
    b.style.width = "75%";
    b.style.textAlign = "left";
    b.style.padding = "6px 8px";
    b.style.border = "1px solid rgba(0,0,0,0.18)";
    b.style.background = "#fff";
    b.style.borderRadius = "10px";
    b.style.cursor = "pointer";
    b.style.fontSize = "13px";
    b.style.marginRight = "8px";

    b.addEventListener("click", (e) => {
      e.stopPropagation();
      setPVC(value);
    });
    return b;
  }

  group.appendChild(makeOpt("Wedges", "wedges"));
  group.appendChild(makeOpt("Add-A-Board", "addaboard"));

  
  pvcBtn.addEventListener("click", (e) => {
    e.stopPropagation();

    // Accordion behavior: only one tool's options open at a time
    try{
      // close all other option groups (gutter/downspout/covers) and any other PVC groups
      document.querySelectorAll("#leftPanel .optGroup").forEach(g => { g.style.display = "none"; });
      document.querySelectorAll("#leftPanel .pvcGroup").forEach(g => { if (g !== group) g.style.display = "none"; });
    }catch(_){}

    // toggle this PVC group
    const willOpen = (group.style.display === "none");
    group.style.display = willOpen ? "flex" : "none";

    activatePVCTool();
    // ensure a selection stays highlighted
    setPVC(pvcType || "wedges");
  });

  anchor.insertAdjacentElement("afterend", pvcBtn);
  pvcBtn.insertAdjacentElement("afterend", group);

  // active outline
  const style = document.createElement("style");
  style.textContent = `.pvcGroup .pvcOptBtn.active{ outline:2px solid orange; }`;
  document.head.appendChild(style);

  // initial state
  }




/* ---------- TOOLBAR UI INJECTION (COLOR DROPDOWNS) ---------- */
function removeToolbarColorDropdowns() {
  // Ensure color dropdowns do NOT appear in the top toolbar.
  // Project Info panel owns #gutterColorSelect and #downspoutColorSelect.
  const toolbar = document.getElementById("toolbar");
  if (!toolbar) return;

  // Remove legacy injected wrapper
  const wrap = document.getElementById("colorWrap");
  if (wrap && toolbar.contains(wrap)) wrap.remove();

  // Remove any stray selects inside toolbar (but never touch the Info Panel)
  const strayIds = ["gutterColorSelect", "downspoutColorSelect"];
  for (const id of strayIds) {
    const el = toolbar.querySelector("#" + id);
    if (el) el.remove();
  }
}

let colorWrap = null;
let gutterColorSelect = null;
let downspoutColorSelect = null;

function buildColorDropdownUI() {
  // Colors now live inside the Project Info section (Info Panel) if those selects exist.
  const gSel = document.getElementById("gutterColorSelect");
  const dSel = document.getElementById("downspoutColorSelect");

  const fillSelect = (sel, current, onChangeFn) => {
    if (!sel) return;
    sel.innerHTML = "";
    const p = document.createElement("option");
    p.value = "Please Select";
    p.textContent = "Please Select";
    sel.appendChild(p);
    COLOR_OPTIONS.forEach(name => {
      const o = document.createElement("option");
      o.value = name;
      o.textContent = name;
      sel.appendChild(o);
    });
    sel.value = current || "Please Select";
    sel.onchange = () => onChangeFn(sel.value);
  };

  if (gSel || dSel) {
    fillSelect(gSel, gutterColorName, setGutterColor);
    fillSelect(dSel, downspoutColorName, setDownspoutColor);
    removeToolbarColorDropdowns();
    return; // Project Info panel owns these (no toolbar fallback)
  }

  // Fallback (older layouts): inject into toolbar if Project Info selects are not present.
  const rows = document.querySelectorAll("#toolbar .toolbar-row");
  if (!rows || !rows.length) return;
  const row = rows[1] || rows[0];
  if (document.getElementById("colorWrap")) return;

  colorWrap = document.createElement("span");
  colorWrap.id = "colorWrap";
  stylePill(colorWrap);

  const gLabel = document.createElement("span");
  gLabel.textContent = "Gutter:";
  styleMiniLabel(gLabel);

  gutterColorSelect = document.createElement("select");
  gutterColorSelect.id = "gutterColorSelect";
  styleSelect(gutterColorSelect);

  const p0 = document.createElement("option");
  p0.value = "Please Select";
  p0.textContent = "Please Select";
  gutterColorSelect.appendChild(p0);
  COLOR_OPTIONS.forEach(name => {
    const o = document.createElement("option");
    o.value = name;
    o.textContent = name;
    gutterColorSelect.appendChild(o);
  });
  gutterColorSelect.value = gutterColorName;
  gutterColorSelect.onchange = () => setGutterColor(gutterColorSelect.value);

  const dsLabel = document.createElement("span");
  dsLabel.textContent = "DS:";
  styleMiniLabel(dsLabel);

  downspoutColorSelect = document.createElement("select");
  downspoutColorSelect.id = "downspoutColorSelect";
  styleSelect(downspoutColorSelect);

  const p1 = document.createElement("option");
  p1.value = "Please Select";
  p1.textContent = "Please Select";
  downspoutColorSelect.appendChild(p1);
  COLOR_OPTIONS.forEach(name => {
    const o = document.createElement("option");
    o.value = name;
    o.textContent = name;
    downspoutColorSelect.appendChild(o);
  });
  downspoutColorSelect.value = downspoutColorName;
  downspoutColorSelect.onchange = () => setDownspoutColor(downspoutColorSelect.value);

  colorWrap.appendChild(gLabel);
  colorWrap.appendChild(gutterColorSelect);
  colorWrap.appendChild(dsLabel);
  colorWrap.appendChild(downspoutColorSelect);

  row.appendChild(colorWrap);
}

function updateInjectedVisibility() {
  // Keep injected pills sized to the left panel; visibility is controlled by toggleOptionGroup().
  if (gutterLevelWrap && gutterLevelSelect) stylePanelPill(gutterLevelWrap, gutterLevelSelect);
  if (dsWrap && dsSelect) stylePanelPill(dsWrap, dsSelect);
  if (coversWrap && coversSelect) stylePanelPill(coversWrap, coversSelect);
}

buildGutterLevelUI();
buildDownspoutUI();
  buildCoversUI();

  buildPVCUI();
ensureNestedButtonsForTool();
buildColorDropdownUI();
removeToolbarColorDropdowns();

/* ---------- INVENTORY (Upper/Lower gutter rows injected) ---------- */
let rowLowerGutter = null, rowUpperGutter = null;
let invLowerEl = null, invUpperEl = null;

function setRowVisible(rowEl, isVisible) {
  rowEl.style.display = isVisible ? "flex" : "none";
}


function ensureTRexRow() {
  if (!inventoryPanel) return;

  const existing = document.getElementById("rowTRex");
  if (existing) {
    rowTRex = existing;
    invTRexEl = document.getElementById("invTRex");
    return;
  }

  const row = document.createElement("div");
  row.className = "invRow";
  row.id = "rowTRex";

  const label = document.createElement("span");
  label.className = "label";
  label.textContent = "T-Rex ¬Æ";

  const value = document.createElement("span");
  value.className = "value";
  value.id = "invTRex";
  value.textContent = "0'";

  row.appendChild(label);
  row.appendChild(value);

  const after = document.getElementById("rowLowerGutter") || document.getElementById("rowUpperGutter");
  if (after && after.insertAdjacentElement) after.insertAdjacentElement("afterend", row);
  else inventoryPanel.appendChild(row);

  rowTRex = row;
  invTRexEl = value;
}



// Gutter Clean¬Æ inventory rows (ft) ‚Äî split Lower/Upper
let rowGutterCleanLower = null;
let rowGutterCleanUpper = null;
let invGutterCleanLowerEl = null;
let invGutterCleanUpperEl = null;

function ensureGutterCleanRows(){
  if (!inventoryPanel) return;

  // Lower
  let existing = document.getElementById("rowGutterCleanLower");
  if (existing){
    rowGutterCleanLower = existing;
    invGutterCleanLowerEl = document.getElementById("invGutterCleanLower");
  } else {
    const row = document.createElement("div");
    row.className = "invRow";
    row.id = "rowGutterCleanLower";
    const label = document.createElement("span");
    label.className = "label";
    label.textContent = "Gutter Clean¬Æ L ft";
    const value = document.createElement("span");
    value.className = "value";
    value.id = "invGutterCleanLower";
    value.textContent = "0'";
    row.appendChild(label);
    row.appendChild(value);

    const after =
      document.getElementById("rowDoublePro") ||
      document.getElementById("rowTRex") ||
      document.getElementById("rowUpper");
    if (after) after.insertAdjacentElement("afterend", row);
    else inventoryPanel.appendChild(row);

    rowGutterCleanLower = row;
    invGutterCleanLowerEl = value;
  }

  // Upper
  existing = document.getElementById("rowGutterCleanUpper");
  if (existing){
    rowGutterCleanUpper = existing;
    invGutterCleanUpperEl = document.getElementById("invGutterCleanUpper");
  } else {
    const row = document.createElement("div");
    row.className = "invRow";
    row.id = "rowGutterCleanUpper";
    const label = document.createElement("span");
    label.className = "label";
    label.textContent = "Gutter Clean¬Æ U ft";
    const value = document.createElement("span");
    value.className = "value";
    value.id = "invGutterCleanUpper";
    value.textContent = "0'";
    row.appendChild(label);
    row.appendChild(value);

    const after = document.getElementById("rowGutterCleanLower");
    if (after) after.insertAdjacentElement("afterend", row);
    else inventoryPanel.appendChild(row);

    rowGutterCleanUpper = row;
    invGutterCleanUpperEl = value;
  }
}


// Gutter Clean PRO¬Æ inventory rows (ft) ‚Äî split Lower/Upper
let rowGutterCleanProLower = null;
let rowGutterCleanProUpper = null;
let invGutterCleanProLowerEl = null;
let invGutterCleanProUpperEl = null;

function ensureGutterCleanProRows(){
  if (!inventoryPanel) return;

  // Lower
  let existing = document.getElementById("rowGutterCleanProLower");
  if (existing){
    rowGutterCleanProLower = existing;
    invGutterCleanProLowerEl = document.getElementById("invGutterCleanProLower");
  } else {
    const row = document.createElement("div");
    row.className = "invRow";
    row.id = "rowGutterCleanProLower";
    const label = document.createElement("span");
    label.className = "label";
    label.textContent = "Gutter Clean PRO¬Æ L ft";
    const value = document.createElement("span");
    value.className = "value";
    value.id = "invGutterCleanProLower";
    value.textContent = "0'";
    row.appendChild(label);
    row.appendChild(value);

    const after =
      document.getElementById("rowGutterCleanUpper") ||
      document.getElementById("rowGutterCleanLower");
    if (after) after.insertAdjacentElement("afterend", row);
    else inventoryPanel.appendChild(row);

    rowGutterCleanProLower = row;
    invGutterCleanProLowerEl = value;
  }

  // Upper
  existing = document.getElementById("rowGutterCleanProUpper");
  if (existing){
    rowGutterCleanProUpper = existing;
    invGutterCleanProUpperEl = document.getElementById("invGutterCleanProUpper");
  } else {
    const row = document.createElement("div");
    row.className = "invRow";
    row.id = "rowGutterCleanProUpper";
    const label = document.createElement("span");
    label.className = "label";
    label.textContent = "Gutter Clean PRO¬Æ U ft";
    const value = document.createElement("span");
    value.className = "value";
    value.id = "invGutterCleanProUpper";
    value.textContent = "0'";
    row.appendChild(label);
    row.appendChild(value);

    const after = document.getElementById("rowGutterCleanProLower");
    if (after) after.insertAdjacentElement("afterend", row);
    else inventoryPanel.appendChild(row);

    rowGutterCleanProUpper = row;
    invGutterCleanProUpperEl = value;
  }
}
function ensureDoubleProRow() {
  if (!inventoryPanel) return;

  const existing = document.getElementById("rowDoublePro");
  if (existing) {
    rowDoublePro = existing;
    invDoubleProEl = document.getElementById("invDoublePro");
    return;
  }

  const row = document.createElement("div");
  row.className = "invRow";
  row.id = "rowDoublePro";

  const label = document.createElement("span");
  label.className = "label";
  label.textContent = "Double PRO ¬Æ";

  const value = document.createElement("span");
  value.className = "value";
  value.id = "invDoublePro";
  value.textContent = "0'";

  row.appendChild(label);
  row.appendChild(value);

  const after = document.getElementById("rowTRex") || document.getElementById("rowLowerGutter") || document.getElementById("rowUpperGutter");
  if (after && after.insertAdjacentElement) after.insertAdjacentElement("afterend", row);
  else inventoryPanel.appendChild(row);

  rowDoublePro = row;
  invDoubleProEl = value;
}



function ensureUpperLowerRows() {
  if (!inventoryPanel) return;

  if (document.getElementById("rowLowerGutter") && document.getElementById("rowUpperGutter")) {
    rowLowerGutter = document.getElementById("rowLowerGutter");
    rowUpperGutter = document.getElementById("rowUpperGutter");
    invLowerEl = document.getElementById("invLowerGutter");
    invUpperEl = document.getElementById("invUpperGutter");
    return;
  }

  // Hide the original single total gutter row (we'll track separately now)
  if (rowTotalGutter) rowTotalGutter.style.display = "none";

  // Insert after invEmpty (top area)
  const anchor = document.getElementById("invEmpty") || inventoryPanel.firstChild;

  const makeRow = (rowId, labelText, valueId) => {
    const row = document.createElement("div");
    row.className = "invRow";
    row.id = rowId;

    const label = document.createElement("span");
    label.className = "label";
    label.textContent = labelText;

    const value = document.createElement("span");
    value.className = "value";
    value.id = valueId;
    value.textContent = "0'";

    row.appendChild(label);
    row.appendChild(value);
    return row;
  };

  rowLowerGutter = makeRow("rowLowerGutter", "Lower Gutter", "invLowerGutter");
  rowUpperGutter = makeRow("rowUpperGutter", "Upper Gutter", "invUpperGutter");

  // Insert these rows right after the empty message element
  if (anchor && anchor.parentNode) {
    // If anchor is invEmpty, insert after it; else at the top
    if (anchor.id === "invEmpty") {
      anchor.insertAdjacentElement("afterend", rowUpperGutter);
      rowUpperGutter.insertAdjacentElement("afterend", rowLowerGutter);
    } else {
      inventoryPanel.insertBefore(rowUpperGutter, inventoryPanel.firstChild);
      inventoryPanel.insertBefore(rowLowerGutter, inventoryPanel.firstChild);
    }
  } else {
    inventoryPanel.appendChild(rowUpperGutter);
    inventoryPanel.appendChild(rowLowerGutter);
  }

  invLowerEl = document.getElementById("invLowerGutter");
  invUpperEl = document.getElementById("invUpperGutter");
}




// PVC Inventory rows (ft only; pricing later)
let rowPVCWedgesLower = null, rowPVCWedgesUpper = null, rowPVCAddLower = null, rowPVCAddUpper = null;
let invPVCWedgesLowerEl = null, invPVCWedgesUpperEl = null, invPVCAddLowerEl = null, invPVCAddUpperEl = null;

function ensurePVCRows() {
  if (!inventoryPanel) return;

  function makeRow(id, labelText, valueId) {
    const existing = document.getElementById(id);
    if (existing) return existing;

    const row = document.createElement("div");
    row.className = "invRow";
    row.id = id;

    const label = document.createElement("span");
    label.className = "label";
    label.textContent = labelText;

    const value = document.createElement("span");
    value.className = "value";
    value.id = valueId;
    value.textContent = "0'";

    row.appendChild(label);
    row.appendChild(value);

    const after = document.getElementById("rowDoublePro") || document.getElementById("rowTRex") || document.getElementById("rowUpperGutter") || document.getElementById("rowLowerGutter");
    if (after && after.insertAdjacentElement) after.insertAdjacentElement("afterend", row);
    else inventoryPanel.appendChild(row);

    return row;
  }

  rowPVCWedgesLower = makeRow("rowPVCWedgesLower", "PVC Wedges (Lower) ft", "invPVCWedgesLower");
  rowPVCWedgesUpper = makeRow("rowPVCWedgesUpper", "PVC Wedges (Upper) ft", "invPVCWedgesUpper");
  rowPVCAddLower    = makeRow("rowPVCAddLower",    "Add-A-Board (Lower) ft", "invPVCAddLower");
  rowPVCAddUpper    = makeRow("rowPVCAddUpper",    "Add-A-Board (Upper) ft", "invPVCAddUpper");

  invPVCWedgesLowerEl = document.getElementById("invPVCWedgesLower");
  invPVCWedgesUpperEl = document.getElementById("invPVCWedgesUpper");
  invPVCAddLowerEl    = document.getElementById("invPVCAddLower");
  invPVCAddUpperEl    = document.getElementById("invPVCAddUpper");
}


function ensureSplashGuardRow() {
  if (!inventoryPanel) return;

  const existing = document.getElementById("rowSplashGuard");
  if (existing) {
    rowSplashGuard = existing;
    invSplashGuardEl = document.getElementById("invSplashGuard");
    return;
  }

  const row = document.createElement("div");
  row.className = "invRow";
  row.id = "rowSplashGuard";

  const label = document.createElement("span");
  label.className = "label";
  label.textContent = "Splash Guard";

  const value = document.createElement("span");
  value.className = "value";
  value.id = "invSplashGuard";
  value.textContent = "0";

  row.appendChild(label);
  row.appendChild(value);

  // Place near other accessory rows (after Double PRO if present, else after T-Rex)
  const after = document.getElementById("rowDoublePro") || document.getElementById("rowTRex") || document.getElementById("rowUpperGutter") || document.getElementById("rowLowerGutter");
  if (after && after.insertAdjacentElement) after.insertAdjacentElement("afterend", row);
  else inventoryPanel.appendChild(row);

  rowSplashGuard = row;
  invSplashGuardEl = value;
}
function cornerAngleDegAtPoint(cx, cy) {
  const EPS = 0.01;
  const touches = [];
  for (const l of lines) {
    if (!l) continue;
    const aMatch = Math.abs(l.x1 - cx) <= EPS && Math.abs(l.y1 - cy) <= EPS;
    const bMatch = Math.abs(l.x2 - cx) <= EPS && Math.abs(l.y2 - cy) <= EPS;
    if (!aMatch && !bMatch) continue;

    let vx, vy;
    if (aMatch) { vx = l.x2 - l.x1; vy = l.y2 - l.y1; }
    else { vx = l.x1 - l.x2; vy = l.y1 - l.y2; }

    const mag = Math.hypot(vx, vy);
    if (mag > EPS) touches.push({ vx: vx / mag, vy: vy / mag });
  }
  if (touches.length < 2) return null;
  const v1 = touches[0], v2 = touches[1];
  let dot = v1.vx * v2.vx + v1.vy * v2.vy;
  dot = Math.max(-1, Math.min(1, dot));
  return Math.acos(dot) * 180 / Math.PI; // 0..180
}
function isBoxMiter(angleDeg) {
  return (typeof angleDeg === "number" && isFinite(angleDeg) && Math.abs(angleDeg - 90) <= 1);
}

function ensureAccessoriesRows() {
  if (!inventoryPanel) return;

  // Container for accessory rows in the inventory totals area
  let section = document.getElementById("accessoryInvSection");
  if (!section) {
    section = document.createElement("div");
    section.id = "accessoryInvSection";

    // Insert after Splash Guards row if present, otherwise after the last known totals row.
    const anchor =
      document.getElementById("rowSplashGuard") ||
      document.getElementById("rowPVCAddUpper") ||
      document.getElementById("rowPVCAddLower") ||
      document.getElementById("rowPVCWedgesUpper") ||
      document.getElementById("rowPVCWedgesLower") ||
      document.getElementById("rowDoublePro") ||
      document.getElementById("rowTRex") ||
      document.getElementById("rowUpperGutter") ||
      document.getElementById("rowLowerGutter");

    if (anchor && anchor.insertAdjacentElement) anchor.insertAdjacentElement("afterend", section);
    else inventoryPanel.appendChild(section);
  }

  for (const name of ACCESSORY_ITEMS) {
    const safeId = "acc_" + name.replace(/[^a-z0-9]+/gi, "_");
    const rowId = "row_" + safeId;
    const valId = "val_" + safeId;

    let row = document.getElementById(rowId);
    if (!row) {
      row = document.createElement("div");
      row.className = "invRow";
      row.id = rowId;

      const label = document.createElement("span");
      label.className = "label";
      label.textContent = name;

      const value = document.createElement("span");
      value.className = "value";
      value.id = valId;
      value.textContent = "0";

      row.appendChild(label);
      row.appendChild(value);
      section.appendChild(row);
    }
  }
}



function ensureMiscUI() {
  const body = document.getElementById("inventoryBody");
  if (!body) return;

  let wrap = document.getElementById("miscWrap");
  if (wrap) return;

  wrap = document.createElement("div");
  wrap.id = "miscWrap";

  const spacer = document.createElement("div");
  spacer.className = "miscSpacer";

  const header = document.createElement("div");
  header.className = "miscHeader";
  header.textContent = "";

  const list = document.createElement("div");
  list.className = "miscList";
  list.id = "miscList";

  const addBtn = document.createElement("button");
  addBtn.id = "btnAddMisc";
  addBtn.textContent = "Misc";
  addBtn.onclick = () => {
    
    closeInventoryInlineForms();
    setInventoryActiveButton(addBtn);
    const form = document.getElementById("miscForm");
    if (form) {
      form.style.display = "flex";
      const d = document.getElementById("miscDesc");
      if (d) d.focus();
    }
  };

  const form = document.createElement("div");
  form.className = "miscForm";
  form.id = "miscForm";
  form.style.display = "none";

  const desc = document.createElement("input");
  desc.type = "text";
  desc.id = "miscDesc";
  desc.placeholder = "Description";

  const price = document.createElement("input");
  price.type = "number";
  price.id = "miscPrice";
  price.placeholder = "Price";
  price.step = "0.01";

  const add = document.createElement("button");
  add.textContent = "Add";
  add.onclick = () => {
    const d = (desc.value || "").trim();
    const p = Number(price.value || 0);
    if (!d) {
      if (typeof showToast === "function") showToast("Enter a description");
      desc.focus();
      return;
    }
    saveState();
    miscItems.push({ desc: d, price: isFinite(p) ? p : 0 });
    desc.value = "";
    price.value = "";
    form.style.display = "none";
    updateInventory();
    redraw();
    if (typeof showToast === "function") showToast("Misc item added");
  };

  const cancel = document.createElement("button");
  cancel.textContent = "Cancel";
  cancel.onclick = () => {
    desc.value = "";
    price.value = "";
    form.style.display = "none";
  };

  form.appendChild(desc);
  form.appendChild(price);
  form.appendChild(add);
  form.appendChild(cancel);

  // Removal (priced per ft)
  const remBtn = document.createElement("button");
  remBtn.id = "btnRemoval";
  remBtn.textContent = "Removal";
  remBtn.onclick = () => {
    closeInventoryInlineForms();
    setInventoryActiveButton(remBtn);
    const f = document.getElementById("removalForm");
    const t = document.getElementById("removalTitle");
    if (t) t.style.display = "";
    if (f) {
      f.style.display = "flex";
      const ft = document.getElementById("removalFt");
      if (ft) ft.focus();
    }
  };

  const remForm = document.createElement("div");
  remForm.className = "miscForm";
  remForm.id = "removalForm";
  remForm.style.display = "none";

  const ftInput = document.createElement("input");
  ftInput.type = "number";
  ftInput.id = "removalFt";
  ftInput.placeholder = "Ft";
  ftInput.step = "0.5";
  ftInput.min = "0";

  const allBtn = document.createElement("button");
  allBtn.textContent = "All";
  allBtn.onclick = () => {
    setInventoryActiveButton(allBtn);
    const total = getGutterOnlyTotalFt();
    ftInput.value = String(Math.max(0, Math.round(total * 2) / 2));
    ftInput.focus();
  };

  const addRem = document.createElement("button");
  addRem.textContent = "Add";
  addRem.onclick = () => {
    const ftVal = Number(ftInput.value || 0);
    const ft = isFinite(ftVal) ? Math.max(0, Math.round(ftVal * 2) / 2) : 0;
    if (!ft) {
      if (typeof showToast === "function") showToast("Enter removal ft");
      ftInput.focus();
      return;
    }
    saveState();
    miscItems.push({ desc: `Removal (${ft} ft)`, price: ft * 2.0 });
    ftInput.value = "";
    remForm.style.display = "none";
    updateInventory();
    redraw();
    if (typeof showToast === "function") showToast("Removal added");
  
    const f = document.getElementById("removalForm");
    const t = document.getElementById("removalTitle");
    if (f) f.style.display = "none";
    if (t) t.style.display = "none";
  };

  const cancelRem = document.createElement("button");
  cancelRem.textContent = "Cancel";
  cancelRem.onclick = () => {
    const f = document.getElementById("removalForm");
    const t = document.getElementById("removalTitle");
    if (f) f.style.display = "none";
    if (t) t.style.display = "none";
  };

  remForm.appendChild(ftInput);
  remForm.appendChild(allBtn);
  remForm.appendChild(addRem);
  remForm.appendChild(cancelRem);

  // Wedges (priced per ft)
  const wedBtn = document.createElement("button");
  wedBtn.id = "btnWedges";
  wedBtn.textContent = "Wedges";
  wedBtn.onclick = () => {
    closeInventoryInlineForms();
    setInventoryActiveButton(wedBtn);
    const f = document.getElementById("wedgesForm");
    const t = document.getElementById("wedgesTitle");
    if (t) t.style.display = "";
    if (f) {
      f.style.display = "flex";
      const ft = document.getElementById("wedgesFt");
      if (ft) ft.focus();
    }
  };

  const wedForm = document.createElement("div");
  wedForm.className = "miscForm";
  wedForm.id = "wedgesForm";
  wedForm.style.display = "none";

  const wFtInput = document.createElement("input");
  wFtInput.type = "number";
  wFtInput.id = "wedgesFt";
  wFtInput.placeholder = "Ft";
  wFtInput.step = "0.5";
  wFtInput.min = "0";

  const wAllBtn = document.createElement("button");
  wAllBtn.textContent = "All";
  wAllBtn.onclick = () => {
    setInventoryActiveButton(wAllBtn);
    const total = getGutterOnlyTotalFt();
    wFtInput.value = String(Math.max(0, Math.round(total * 2) / 2));
    wFtInput.focus();
  };

  const wAdd = document.createElement("button");
  wAdd.textContent = "Add";
  wAdd.onclick = () => {
    const ftVal = Number(wFtInput.value || 0);
    const ft = isFinite(ftVal) ? Math.max(0, Math.round(ftVal * 2) / 2) : 0;
    if (!ft) {
      if (typeof showToast === "function") showToast("Enter wedges ft");
      wFtInput.focus();
      return;
    }
    saveState();
    miscItems.push({ desc: `Wedges (${ft} ft)`, price: ft * 2.0 });
    wFtInput.value = "";
    wedForm.style.display = "none";
    updateInventory();
    redraw();
    if (typeof showToast === "function") showToast("Wedges added");
  
    const f = document.getElementById("wedgesForm");
    const t = document.getElementById("wedgesTitle");
    if (f) f.style.display = "none";
    if (t) t.style.display = "none";
  };

  const wCancel = document.createElement("button");
  wCancel.textContent = "Cancel";
  wCancel.onclick = () => {
    const f = document.getElementById("wedgesForm");
    const t = document.getElementById("wedgesTitle");
    if (f) f.style.display = "none";
    if (t) t.style.display = "none";
  };

  wedForm.appendChild(wFtInput);
  wedForm.appendChild(wAllBtn);
  wedForm.appendChild(wAdd);
  wedForm.appendChild(wCancel);


  // Drip Strip (priced per ft)
  const dripBtn = document.createElement("button");
  dripBtn.id = "btnDripStrip";
  dripBtn.textContent = "Drip Strip";
  dripBtn.onclick = () => {
    closeInventoryInlineForms();
    setInventoryActiveButton(dripBtn);
    const f = document.getElementById("dripStripForm");
    const t = document.getElementById("dripStripTitle");
    if (t) t.style.display = "";
    if (f) {
      f.style.display = "flex";
      const ft = document.getElementById("dripStripFt");
      if (ft) ft.focus();
    }
  };


  // Accessories (opens a simple quantity list; no pricing yet)
  const accessoriesBtn = document.createElement("button");
  accessoriesBtn.id = "btnAccessories";
  accessoriesBtn.textContent = "Accessories";

  const accessoriesForm = document.createElement("div");
  accessoriesForm.className = "miscForm";
  accessoriesForm.id = "accessoriesForm";
  accessoriesForm.style.display = "none";
  accessoriesForm.style.flexDirection = "column";
  accessoriesForm.style.gap = "6px";
  accessoriesForm.style.alignItems = "stretch";

  // Header row
  const accHeader = document.createElement("div");
  accHeader.style.display = "flex";
  accHeader.style.justifyContent = "space-between";
  accHeader.style.alignItems = "center";
  accHeader.style.gap = "8px";

  const accTitle = document.createElement("div");
  accTitle.textContent = "Accessories";
  accTitle.className = "accTitle";

  const accClose = document.createElement("button");
  accClose.textContent = "Close";
  accClose.style.padding = "3px 8px";
  accClose.onclick = () => { accessoriesForm.style.display = "none"; };

  accHeader.appendChild(accTitle);
  accHeader.appendChild(accClose);
  accessoriesForm.appendChild(accHeader);

  // Item rows
  function setAccQty(name, v) {
    const n = Math.max(0, Math.round(Number(v) || 0));
    accessoryQty[name] = n;
    updateInventory();
  }

  function makeAccessoryRow(name) {
    const row = document.createElement("div");
    row.className = "accRow";

    const lbl = document.createElement("span");
    lbl.className = "accLabel";
    lbl.textContent = name;

    const stepper = document.createElement("div");
    stepper.className = "accStepper";

    const minus = document.createElement("button");
    minus.type = "button";
    minus.className = "accStepBtn";
    minus.textContent = "‚àí";

    const qty = document.createElement("input");
    qty.type = "number";
    qty.className = "accQty";
    qty.min = "0";
    qty.step = "1";
    qty.value = String(accessoryQty[name] || 0);

    const plus = document.createElement("button");
    plus.type = "button";
    plus.className = "accStepBtn";
    plus.textContent = "+";

    const sync = () => { qty.value = String(accessoryQty[name] || 0); };

    minus.onclick = () => { setAccQty(name, (accessoryQty[name] || 0) - 1); sync(); };
    plus.onclick  = () => { setAccQty(name, (accessoryQty[name] || 0) + 1); sync(); };
    qty.oninput   = () => { setAccQty(name, qty.value); };

    stepper.appendChild(minus);
    stepper.appendChild(qty);
    stepper.appendChild(plus);

    row.appendChild(lbl);
    row.appendChild(stepper);
    return row;
  }

  // Item rows
  for (const name of ACCESSORY_ITEMS) {
    accessoriesForm.appendChild(makeAccessoryRow(name));
  }


  accessoriesBtn.onclick = () => {
    closeInventoryInlineForms();
    setInventoryActiveButton(accessoriesBtn);
    const f = document.getElementById("accessoriesForm");
    if (!f) return;
    f.style.display = "block";
  };

  const dripForm = document.createElement("div");
  dripForm.className = "miscForm";
  dripForm.id = "dripStripForm";
  dripForm.style.display = "none";

  const dFtInput = document.createElement("input");
  dFtInput.style.height = "32px";
  dFtInput.style.boxSizing = "border-box";
  dFtInput.type = "number";
  dFtInput.id = "dripStripFt";
  dFtInput.placeholder = "Ft";
  dFtInput.step = "0.5";
  dFtInput.min = "0";

  const dAllBtn = document.createElement("button");
  dAllBtn.textContent = "All";
  dAllBtn.style.height = "32px";
  dAllBtn.style.boxSizing = "border-box";
  dAllBtn.onclick = () => {
    setInventoryActiveButton(dAllBtn);
    const total = getGutterOnlyTotalFt();
    dFtInput.value = String(Math.max(0, Math.round(total * 2) / 2));
    dFtInput.focus();
  };

  const dAdd = document.createElement("button");
  dAdd.textContent = "Add";
  dAdd.onclick = () => {
    const ftVal = Number(dFtInput.value || 0);
    const ft = isFinite(ftVal) ? Math.max(0, Math.round(ftVal * 2) / 2) : 0;
    if (!ft) {
      if (typeof showToast === "function") showToast("Enter drip strip ft");
      dFtInput.focus();
      return;
    }
    saveState();
    // Hard-coded $1/ft as requested (not tied to price list)
    miscItems.push({ desc: `Drip Strip (${ft} ft)`, price: ft * 1.0 });
    dFtInput.value = "";
    dripForm.style.display = "none";
    updateInventory();
    redraw();
    if (typeof showToast === "function") showToast("Drip Strip added");
  
    const f = document.getElementById("dripStripForm");
    const t = document.getElementById("dripStripTitle");
    if (f) f.style.display = "none";
    if (t) t.style.display = "none";
  };

  const dCancel = document.createElement("button");
  dCancel.textContent = "Cancel";
  dCancel.onclick = () => {
    const f = document.getElementById("dripStripForm");
    const t = document.getElementById("dripStripTitle");
    if (f) f.style.display = "none";
    if (t) t.style.display = "none";
  };

  dripForm.appendChild(dFtInput);
  dripForm.appendChild(dAllBtn);
  dripForm.appendChild(dAdd);
  dripForm.appendChild(dCancel);

  wrap.appendChild(list);
  wrap.appendChild(spacer);

  // Action buttons row (3 per row, equal size)
  const actions = document.createElement("div");
  actions.className = "invActions";
  actions.appendChild(addBtn);
  actions.appendChild(remBtn);
  actions.appendChild(wedBtn);
  actions.appendChild(dripBtn);
  actions.appendChild(accessoriesBtn);

  // Forms under buttons
  const forms = document.createElement("div");
  forms.className = "invForms";
  forms.appendChild(form);

  const remTitle = document.createElement("div");
  remTitle.className = "invSectionTitle";
  remTitle.id = "removalTitle";
  remTitle.style.display = "none";
  remTitle.textContent = "REMOVAL";
  forms.appendChild(remTitle);
  forms.appendChild(remForm);

  const wedTitle = document.createElement("div");
  wedTitle.className = "invSectionTitle";
  wedTitle.id = "wedgesTitle";
  wedTitle.style.display = "none";
  wedTitle.textContent = "WEDGES";
  forms.appendChild(wedTitle);
  forms.appendChild(wedForm);

  const dripTitle = document.createElement("div");
  dripTitle.className = "invSectionTitle";
  dripTitle.id = "dripStripTitle";
  dripTitle.style.display = "none";
  dripTitle.textContent = "DRIP STRIP";
  forms.appendChild(dripTitle);
  forms.appendChild(dripForm);
  forms.appendChild(accessoriesForm);

  wrap.appendChild(actions);
  wrap.appendChild(forms);

  body.appendChild(wrap);
}





function renderMiscItems() {
  ensureMiscUI();
  const list = document.getElementById("miscList");
  if (!list) return;
  list.innerHTML = "";

  let editingIndex = null;

  function saveEdit(i, descInput, priceInput) {
    const it = miscItems[i];
    if (!it) return;
    it.desc = descInput.value.trim() || it.desc;
    it.price = Number(priceInput.value || 0);
    updateInventory();
    redraw();
  }

  for (let i = 0; i < miscItems.length; i++) {
    const it = miscItems[i];
    if (!it || !it.desc) continue;

    const row = document.createElement("div");
    row.className = "invRow";

    const desc = document.createElement("div");
    desc.textContent = it.desc;
    desc.style.flex = "1";

    const rightWrap = document.createElement("div");
    rightWrap.style.display = "flex";
    rightWrap.style.gap = "8px";
    rightWrap.style.alignItems = "center";

    const price = document.createElement("div");
    price.className = "invPrice";
    price.textContent = "$" + Number(it.price || 0).toFixed(2);

    const del = document.createElement("button");
    del.className = "invDel";
    del.type = "button";
    del.textContent = "√ó";
    del.onclick = (e) => {
      e.stopPropagation();
      miscItems.splice(i, 1);
      updateInventory();
      redraw();
      if (typeof showToast === "function") showToast("Misc item removed");
    };

    row.onclick = () => {
      if (editingIndex !== null) return;
      editingIndex = i;
      row.classList.add("editing");
      row.innerHTML = "";

      const descInput = document.createElement("input");
      descInput.className = "invEditInput";
      descInput.value = it.desc;
      descInput.style.flex = "1";

      const priceInput = document.createElement("input");
      priceInput.className = "invEditInput invEditPrice";
      priceInput.type = "number";
      priceInput.step = "0.01";
      priceInput.value = it.price;

      row.appendChild(descInput);
      row.appendChild(priceInput);

      setTimeout(() => descInput.focus(), 0);

      const clickAway = (evt) => {
        if (!row.contains(evt.target)) {
          saveEdit(i, descInput, priceInput);
          document.removeEventListener("pointerdown", clickAway, true);
          editingIndex = null;
        }
      };

      document.addEventListener("pointerdown", clickAway, true);
    };

    row.appendChild(desc);
    rightWrap.appendChild(price);
    rightWrap.appendChild(del);
    row.appendChild(rightWrap);

    list.appendChild(row);
  }
}







function ensureCornerIORows() {
  try {
    const body = document.getElementById("inventoryBody");
    if (!body) return;

    // Hide legacy corner rows (Box/Strip) if present, but don't remove to avoid layout issues
    const legacyBox = document.getElementById("rowBoxMiter");
    const legacyStrip = document.getElementById("rowStripMiter");
    if (legacyBox) legacyBox.style.display = "none";
    if (legacyStrip) legacyStrip.style.display = "none";

    // Already created
    if (document.getElementById("rowInsideBox")) return;

    const makeRow = (rowId, label, valId) => {
      const row = document.createElement("div");
      row.className = "invRow";
      row.id = rowId;

      const l = document.createElement("span");
      l.className = "label";
      l.textContent = label;

      const v = document.createElement("span");
      v.className = "value";
      v.id = valId;
      v.textContent = "0";

      row.appendChild(l);
      row.appendChild(v);
      return row;
    };

    const r1 = makeRow("rowInsideBox", "Inside Box Corner", "invInsideBox");
    const r2 = makeRow("rowOutsideBox", "Outside Box Corner", "invOutsideBox");
    const r3 = makeRow("rowInsideStrip", "Inside Strip Miter", "invInsideStrip");
    const r4 = makeRow("rowOutsideStrip", "Outside Strip Miter", "invOutsideStrip");

    // Insert near legacy rows if we can find them, otherwise append
    const ref = legacyStrip || legacyBox;
    if (ref && ref.parentElement === body) {
      body.insertBefore(r1, ref.nextSibling);
      body.insertBefore(r2, ref.nextSibling);
      body.insertBefore(r3, ref.nextSibling);
      body.insertBefore(r4, ref.nextSibling);
    } else {
      body.appendChild(r1);
      body.appendChild(r2);
      body.appendChild(r3);
      body.appendChild(r4);
    }
  } catch (err) {
    // Safety: never allow inventory UI to break drawing/tools
    console.error("ensureCornerIORows failed:", err);
  }
}


// Accessories (no pricing yet)
const ACCESSORY_ITEMS = [
  "Flexgrate",
  "Flex-a-spout",
  "Zip Hinge",
  "Gutter Gate 2x3",
  "Gutter Gate 3x4",
  "Splash Block",
  "Stealth Flow",
  '4" Pipe Adapter 2x3',
  '4" Pipe Adapter 3x4',
  "Rain Barrel Switch",
  "Funnel",
  "Spray Paint",
];

// Accessory prices (each)
const ACCESSORY_PRICES = {
  "Flexgrate": 15,
  "Flex-a-spout": 10,
  "Zip Hinge": 15,
  "Gutter Gate 2x3": 18,
  "Gutter Gate 3x4": 20,
  "Splash Block": 12,
  "Stealth Flow": 20,
  '4" Pipe Adapter 2x3': 10,
  '4" Pipe Adapter 3x4': 10,
  "Rain Barrel Switch": 75,
  "Funnel": 30,
  "Spray Paint": 30,
};

// Stores accessory quantities entered in the Accessories form
const accessoryQty = Object.fromEntries(ACCESSORY_ITEMS.map(n => [n, 0]));


function renderCurrentPriceList(){
  const host = document.getElementById("priceListContainer");
  if (!host) return;

  const rows = [];

  const pushIf = (name, label, unit) => {
    try{
      const v = (typeof window[name] !== "undefined") ? window[name] : (typeof eval(name) !== "undefined" ? eval(name) : undefined);
      if (typeof v !== "undefined") rows.push({ item: label, unit: unit, price: v });
    }catch(_){}
  };

  // Per-foot core
  pushIf("PRICE_LOWER", "Gutter (Lower)", "/ft");
  pushIf("PRICE_UPPER", "Gutter (Upper)", "/ft");
  pushIf("PRICE_TREX", "T‚ÄëRex¬Æ", "/ft");
  pushIf("PRICE_DOUBLEPRO", "Double PRO¬Æ", "/ft");
  pushIf("PRICE_GUTTER_CLEAN", "Gutter Clean¬Æ", "/ft");
  pushIf("PRICE_GUTTER_CLEAN_PRO", "Gutter Clean PRO¬Æ", "/ft");

  // Each items
  pushIf("PRICE_DS_2X3", "Downspout 2x3 (Lower)", "ea");
  pushIf("PRICE_DS_3X4", "Downspout 3x4 (Lower)", "ea");
  pushIf("PRICE_CORNER", "Corner", "ea");
  pushIf("PRICE_REMOVAL", "Removal", "ea");
  pushIf("PRICE_WEDGES", "Wedges", "ea");
  pushIf("PRICE_SPLASHGUARD", "Splash Guard", "ea");

  // Accessories (each)
  try{
    if (typeof ACCESSORY_PRICES !== "undefined"){
      Object.keys(ACCESSORY_PRICES).forEach(k => {
        rows.push({ item: k, unit: "ea", price: ACCESSORY_PRICES[k] });
      });
    }
  }catch(_){}

  // Build table
  const fmt = (n) => {
    const num = Number(n);
    if (!Number.isFinite(num)) return String(n);
    return "$" + num.toFixed(2);
  };

  rows.sort((a,b)=> a.item.localeCompare(b.item));

  let t = '<table><thead><tr><th>Item</th><th>Unit</th><th>Price</th></tr></thead><tbody>';
  for (const r of rows) {
    t += '<tr><td>' + r.item + '</td><td>' + r.unit + '</td><td>' + fmt(r.price) + '</td></tr>';
  }
  if (!rows.length){
    t += '<tr><td colspan="3" style="color:#666; font-style:italic;">No price constants found.</td></tr>';
  }
  t += '</tbody></table>';
  host.innerHTML = t;
}


function getGutterOnlyTotalFt(){
  // For Removal/Wedges/Drip Strip "All": count ONLY actual gutters (lower+upper).
  // Covers (T-Rex, Double PRO, Gutter Clean/PRO, etc.) are stored as lines with a `kind`, so exclude any line with kind.
  try{
    let total = 0;
    for (const l of lines){
      if (!l) continue;
      if (l.kind) continue; // excludes trex/doublepro/clean/cleanpro/etc
      const lvl = (l.level ? l.level : "lower");
      if (lvl !== "lower" && lvl !== "upper") continue;
      total += dist(l);
    }
    return total;
  }catch(_){
    return 0;
  }
}


function setInventoryActiveButton(btn){
  try{
    const scope = document.getElementById("inventoryBody");
    if (!scope || !btn) return;
    scope.querySelectorAll("button.invActive").forEach(b => b.classList.remove("invActive"));
    btn.classList.add("invActive");
  }catch(_){}
}

function closeInventoryInlineForms(){
  // Ensures only one inventory inline editor is open at a time.
  const formIds = ["miscForm","removalForm","wedgesForm","dripStripForm","accessoriesForm"];
  formIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
  const titleIds = ["removalTitle","wedgesTitle","dripStripTitle"];
  titleIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.style.display = "none";
  });
}


function updateInventory() {
  ensureUpperLowerRows();
  ensureTRexRow();
  ensureDoubleProRow();
  ensureGutterCleanRows();
  ensureGutterCleanProRows();
  ensurePVCRows();
  ensureSplashGuardRow();
  ensureAccessoriesRows();
  enforceExclusiveCovers();

  let lowerTotal = 0;
  let upperTotal = 0;

  let gcLowerTotal = 0;
  let gcUpperTotal = 0;
  let gcProLowerTotal = 0;
  let gcProUpperTotal = 0;

  for (const l of lines) {
    const d = dist(l);
    const lvl = (l && l.level) ? l.level : "lower"; // old lines default to lower

    if (l && l.kind === "clean") {
      if (lvl === "upper") gcUpperTotal += d;
      else gcLowerTotal += d;
      continue;
    }
    if (l && l.kind === "cleanpro") {
      if (lvl === "upper") gcProUpperTotal += d;
      else gcProLowerTotal += d;
      continue;
    }

    if (lvl === "upper") upperTotal += d;
    else lowerTotal += d;
  }

  const gutterCleanTotal = gcLowerTotal + gcUpperTotal;
  const gutterCleanProTotal = gcProLowerTotal + gcProUpperTotal;

  
  // Covers (Step 2): T-Rex total (inventory only; selection comes later)
  let trexTotal = 0;
  if (coverTRexLineIds && coverTRexLineIds.size) {
    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (coverTRexLineIds.has(l.id)) trexTotal += dist(l);
    }
  }
  if (invTRexEl) invTRexEl.textContent = trexTotal + "'";
  if (rowTRex) setRowVisible(rowTRex, trexTotal !== 0);


  // Covers: Double PRO total
  let doubleProTotal = 0;
  if (coverDoubleProLineIds && coverDoubleProLineIds.size) {
    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (coverDoubleProLineIds.has(l.id)) doubleProTotal += dist(l);
    }
  }
  if (invDoubleProEl) invDoubleProEl.textContent = doubleProTotal + "'";
  if (rowDoublePro) setRowVisible(rowDoublePro, doubleProTotal !== 0);

  // PVC totals (ft only; prices later)
  let pvcWLower = 0, pvcWUpper = 0, pvcALower = 0, pvcAUpper = 0;

  if (pvcWedgesLineIds && pvcWedgesLineIds.size) {
    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (!pvcWedgesLineIds.has(l.id)) continue;
      const lvl = (l && l.level) ? l.level : "lower";
      if (lvl === "upper") pvcWUpper += dist(l);
      else pvcWLower += dist(l);
    }
  }
  if (pvcAddBoardLineIds && pvcAddBoardLineIds.size) {
    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (!pvcAddBoardLineIds.has(l.id)) continue;
      const lvl = (l && l.level) ? l.level : "lower";
      if (lvl === "upper") pvcAUpper += dist(l);
      else pvcALower += dist(l);
    }
  }

  if (invPVCWedgesLowerEl) invPVCWedgesLowerEl.textContent = pvcWLower + "'";
  if (invPVCWedgesUpperEl) invPVCWedgesUpperEl.textContent = pvcWUpper + "'";
  if (invPVCAddLowerEl)    invPVCAddLowerEl.textContent    = pvcALower + "'";
  if (invPVCAddUpperEl)    invPVCAddUpperEl.textContent    = pvcAUpper + "'";

  if (rowPVCWedgesLower) setRowVisible(rowPVCWedgesLower, pvcWLower !== 0);
  if (rowPVCWedgesUpper) setRowVisible(rowPVCWedgesUpper, pvcWUpper !== 0);
  if (rowPVCAddLower)    setRowVisible(rowPVCAddLower,    pvcALower !== 0);
  if (rowPVCAddUpper)    setRowVisible(rowPVCAddUpper,    pvcAUpper !== 0);


let c2 = 0, c3 = 0;
  for (const d of downspouts) {
    if (!d || !d.line) continue;
    const t = (d.type || "2x3");
    const qty = (typeof d.qty === "number") ? Math.max(1, Math.min(4, Math.round(d.qty))) : dsQtyDefaultForLine(d.line);
    if (t === "3x4") c3 += qty;
    else c2 += qty;
  }

  // Raw downspout counts (ignores any Upgrade swaps)
  window.__RAW_DS_2X3 = c2;
  window.__RAW_DS_3X4 = c3;

  // Effective counts for inventory/pricing when Upgrade-to-3x4 is accepted
  const e2 = window.__UPG_SWAP_3X4 ? 0 : c2;
  const e3 = window.__UPG_SWAP_3X4 ? (c3 + c2) : c3;

  // Determine corner miter type from the two connected gutter segments
  let boxMiters = 0;
  let stripMiters = 0;
  for (const c of corners) {
    if (!c) continue;
    const ang = cornerAngleDegAtPoint(c.x, c.y);
    if (isBoxMiter(ang)) boxMiters += 1;
    else stripMiters += 1;
  }

  if (invLowerEl) invLowerEl.textContent = lowerTotal + "'";
  if (invUpperEl) invUpperEl.textContent = upperTotal + "'";

  // Gutter Clean totals (split L/U)
  if (invGutterCleanLowerEl) invGutterCleanLowerEl.textContent = gcLowerTotal + "'";
  if (invGutterCleanUpperEl) invGutterCleanUpperEl.textContent = gcUpperTotal + "'";
  if (rowGutterCleanLower) setRowVisible(rowGutterCleanLower, gcLowerTotal !== 0);
  if (rowGutterCleanUpper) setRowVisible(rowGutterCleanUpper, gcUpperTotal !== 0);

  // Gutter Clean PRO totals (split L/U)
  if (invGutterCleanProLowerEl) invGutterCleanProLowerEl.textContent = gcProLowerTotal + "'";
  if (invGutterCleanProUpperEl) invGutterCleanProUpperEl.textContent = gcProUpperTotal + "'";
  if (rowGutterCleanProLower) setRowVisible(rowGutterCleanProLower, gcProLowerTotal !== 0);
  if (rowGutterCleanProUpper) setRowVisible(rowGutterCleanProUpper, gcProUpperTotal !== 0);

  // Raw Gutter Clean ft (for upgrades)
  window.__RAW_GC_FT = gutterCleanTotal;

  inv2x3El.textContent = String(e2);
  
  const inv2x3PriceEl = document.getElementById("inv2x3Price");
  if (inv2x3PriceEl) inv2x3PriceEl.textContent = "$" + (e2 * DS_PRICE_2X3).toFixed(2);
inv3x4El.textContent = String(e3);
  
  const inv3x4PriceEl = document.getElementById("inv3x4Price");
  if (inv3x4PriceEl) inv3x4PriceEl.textContent = "$" + (e3 * DS_PRICE_3X4).toFixed(2);

  // Total price (all items, fixed price list)
  const PRICE_LOWER = 10;
const PRICE_GUTTER_CLEAN = 11;
const PRICE_GUTTER_CLEAN_PRO = 16;
  const PRICE_UPPER = 11;
  const PRICE_TREX = 9;
  const PRICE_DOUBLEPRO = 14;
  const PRICE_DS_2X3 = 80;
  const PRICE_DS_3X4 = 130;
  const PRICE_CORNER = 50;
  const PRICE_REMOVAL = 2;
  const PRICE_WEDGES = 2;
  const PRICE_SPLASHGUARD = 25;
  // Expose price constants to Settings panel (global)
  window.PRICE_LOWER = PRICE_LOWER;
  window.PRICE_GUTTER_CLEAN = PRICE_GUTTER_CLEAN;
  window.PRICE_GUTTER_CLEAN_PRO = PRICE_GUTTER_CLEAN_PRO;
  window.PRICE_UPPER = PRICE_UPPER;
  window.PRICE_TREX = PRICE_TREX;
  window.PRICE_DOUBLEPRO = PRICE_DOUBLEPRO;
  window.PRICE_DS_2X3 = PRICE_DS_2X3;
  window.PRICE_DS_3X4 = PRICE_DS_3X4;
  window.PRICE_CORNER = PRICE_CORNER;
  window.PRICE_REMOVAL = PRICE_REMOVAL;
  window.PRICE_WEDGES = PRICE_WEDGES;
  window.PRICE_SPLASHGUARD = PRICE_SPLASHGUARD;


  let miscOtherTotal = 0;
  let removalFt = 0;
  let wedgesFt = 0;


  // Accessories total
  let accessoriesTotal = 0;
  try {
    for (const name of ACCESSORY_ITEMS) {
      const qty = Math.max(0, parseInt(accessoryQty[name] || 0, 10) || 0);
      const unit = Number(ACCESSORY_PRICES[name] || 0);
      accessoriesTotal += qty * unit;
    }
  } catch (err) {}
  try {
    for (const it of miscItems) {
      const desc = (it && it.desc) ? String(it.desc) : "";
      const m1 = desc.match(/^Removal\s*\(([-0-9.]+)\s*ft\)/i);
      const m2 = desc.match(/^Wedges\s*\(([-0-9.]+)\s*ft\)/i);
      if (m1) {
        const ft = Number(m1[1]);
        if (isFinite(ft)) removalFt += Math.max(0, ft);
      } else if (m2) {
        const ft = Number(m2[1]);
        if (isFinite(ft)) wedgesFt += Math.max(0, ft);
      } else {
        miscOtherTotal += Number((it && it.price) ? it.price : 0);
      }
    }
  } catch (err) {}

  const cornerCount = (corners && corners.length) ? corners.length : 0;
  const splashQty = (Array.isArray(splashGuards) && splashGuards.length) ? splashGuards.length : 0;

  // Splash Guard row (qty)
  if (invSplashGuardEl) invSplashGuardEl.textContent = String(splashQty);
  if (rowSplashGuard) setRowVisible(rowSplashGuard, splashQty !== 0);

  const totalPrice =
    (lowerTotal * PRICE_LOWER) +
    (upperTotal * PRICE_UPPER) +
    (trexTotal * PRICE_TREX) +
    (doubleProTotal * PRICE_DOUBLEPRO) +
    (gutterCleanTotal * PRICE_GUTTER_CLEAN) +
    (gutterCleanProTotal * PRICE_GUTTER_CLEAN_PRO) +
    (e2 * PRICE_DS_2X3) +
    (e3 * PRICE_DS_3X4) +
    (cornerCount * PRICE_CORNER) +
    (removalFt * PRICE_REMOVAL) +
    (wedgesFt * PRICE_WEDGES) +
    (splashQty * PRICE_SPLASHGUARD) +
    miscOtherTotal +
    accessoriesTotal;

  const invTotalPriceEl = document.getElementById("invTotalPrice");
  if (invTotalPriceEl) invTotalPriceEl.textContent = "$" + totalPrice.toFixed(2);
  const invHdrTotalEl = document.getElementById("inventoryHeaderTotal");
  if (invHdrTotalEl) invHdrTotalEl.textContent = "$" + totalPrice.toFixed(2);

  const floatingTotalEl = document.getElementById("floatingTotal");
  if (floatingTotalEl) floatingTotalEl.textContent = "$" + totalPrice.toFixed(2);
if (invBoxMiterEl) invBoxMiterEl.textContent = String(boxMiters);
  if (invStripMiterEl) invStripMiterEl.textContent = String(stripMiters);
  if (rowLowerGutter) setRowVisible(rowLowerGutter, lowerTotal !== 0);
  if (rowUpperGutter) setRowVisible(rowUpperGutter, upperTotal !== 0);

  setRowVisible(row2x3, e2 !== 0);
  setRowVisible(row3x4, e3 !== 0);
  if (rowBoxMiter) setRowVisible(rowBoxMiter, boxMiters !== 0);
  if (rowStripMiter) setRowVisible(rowStripMiter, stripMiters !== 0);
  const anyVisible = (lowerTotal !== 0) || (upperTotal !== 0) || (gcLowerTotal !== 0) || (gcUpperTotal !== 0) || (gcProLowerTotal !== 0) || (gcProUpperTotal !== 0) || (trexTotal !== 0) || (doubleProTotal !== 0) || (e2 !== 0) || (e3 !== 0) || (boxMiters !== 0) || (stripMiters !== 0);
  invEmptyEl.style.display = anyVisible ? "none" : "block";
  renderMiscItems();
  // Corner IO inventory (IC/OC) ‚Äî safe add-on (does not affect drawing)
  try {
    ensureCornerIORows();

    let insideBox = 0, outsideBox = 0, insideStrip = 0, outsideStrip = 0;

    for (const c of corners) {
      if (!c) continue;
      const ang = cornerAngleDegAtPoint(c.x, c.y);
      const kind = isBoxMiter(ang) ? "box" : "strip";
      const io = getCornerIO(c.x, c.y); // "IC" or "OC"

      if (kind === "box") {
        if (io === "OC") outsideBox++;
        else insideBox++;
      } else {
        if (io === "OC") outsideStrip++;
        else insideStrip++;
      }
    }

    const invInsideBoxEl = document.getElementById("invInsideBox");
    const invOutsideBoxEl = document.getElementById("invOutsideBox");
    const invInsideStripEl = document.getElementById("invInsideStrip");
    const invOutsideStripEl = document.getElementById("invOutsideStrip");

    if (invInsideBoxEl) invInsideBoxEl.textContent = String(insideBox);
    if (invOutsideBoxEl) invOutsideBoxEl.textContent = String(outsideBox);
    if (invInsideStripEl) invInsideStripEl.textContent = String(insideStrip);
    if (invOutsideStripEl) invOutsideStripEl.textContent = String(outsideStrip);

    const rowInsideBox = document.getElementById("rowInsideBox");
    const rowOutsideBox = document.getElementById("rowOutsideBox");
    const rowInsideStrip = document.getElementById("rowInsideStrip");
    const rowOutsideStrip = document.getElementById("rowOutsideStrip");

    if (rowInsideBox) setRowVisible(rowInsideBox, insideBox !== 0);
    if (rowOutsideBox) setRowVisible(rowOutsideBox, outsideBox !== 0);
    if (rowInsideStrip) setRowVisible(rowInsideStrip, insideStrip !== 0);
    if (rowOutsideStrip) setRowVisible(rowOutsideStrip, outsideStrip !== 0);
  } catch (err) {
    console.error("Corner IO inventory update failed:", err);
  }


  // Accessories: show any items with qty > 0 as inventory rows
  try {
    for (const name of ACCESSORY_ITEMS) {
      const safeId = "acc_" + name.replace(/[^a-z0-9]+/gi, "_");
      const row = document.getElementById("row_" + safeId);
      const val = document.getElementById("val_" + safeId);
      const qty = Math.max(0, parseInt(accessoryQty[name] || 0, 10) || 0);

      const unit = Number(ACCESSORY_PRICES[name] || 0);
      const lineTotal = qty * unit;
      if (val) {
        val.textContent = (qty > 0 && unit > 0)
          ? (String(qty) + "  $" + lineTotal.toFixed(2))
          : String(qty);
      }
      if (row) setRowVisible(row, qty > 0);
    }
  } catch (err) {
    console.warn("Accessories inventory update failed:", err);
  }
}


/* ---------- INVENTORY BUTTONS ---------- */
function toggleLabels() {
  // Bottom toolbar "Hide Labels" toggle (independent from 1-of-N tool selection)
  showLabels = !showLabels;

  // Selected (active) state means labels are hidden
  const ft = document.getElementById("ft-labels");
  if (ft) ft.classList.toggle("active", !showLabels);

  // Keep any panels in sync, then redraw
  syncInfoPanelFromState();
  syncProjectInfoPanelFromState();
  updatePanelOffsets();
  redraw();
}

/* ---------- LEFT PANEL OPTION BUTTON GROUPS (no dropdowns) ---------- */
function lpRemoveOldOptionRows() {
  const lp = document.getElementById("leftPanel");
  if (!lp) return;

  // remove any previously injected option rows/selects/groups (nested buttons mode)
  lp.querySelectorAll(".lp-row, .optGroup, button.optBtn").forEach(el => el.remove());

  // remove legacy pill-wrapped dropdown UI (these caused the "empty pill" boxes)
  const legacyIds = ["gutterLevelWrap", "dsWrap", "coversWrap"];
  for (const id of legacyIds) {
    const el = document.getElementById(id);
    if (el && lp.contains(el)) el.remove();
  }

  // remove any stray selects that might remain inside left panel
  lp.querySelectorAll("select").forEach(el => el.remove());
}


function makeOptGroup(options, getValue, setValue) {
  const group = document.createElement("div");
  group.className = "optGroup";

  function render() {
    const v = getValue();
    for (const btn of group.querySelectorAll("button.optBtn")) {
      btn.classList.toggle("active", btn.dataset.value === String(v));
    }
  }

  for (const opt of options) {
    const b = document.createElement("button");
    b.type = "button";
    b.className = "optBtn";
    b.textContent = opt.label;
    b.dataset.value = opt.value;
    b.onclick = () => {
      setValue(opt.value);
      render();
      redraw();
    };
    group.appendChild(b);
  }

  // initial highlight
  setTimeout(render, 0);

  // Defensive: remove any empty buttons that might slip in
  for (const b of Array.from(group.querySelectorAll("button.optBtn"))) {
    if (!b.textContent || !b.textContent.trim()) b.remove();
  }

  return group;
}


function setExpandedToolOptions(activeTool) {
  const lp = document.getElementById("leftPanel");
  if (!lp) return;
  const groups = lp.querySelectorAll(".optGroup[data-tool]");
  const effectiveTool = (activeTool === "gutterclean" || activeTool === "guttercleanpro") ? "covers" : activeTool;
  groups.forEach(g => {
    const t = g.getAttribute("data-tool");
    g.classList.toggle("collapsed", t !== effectiveTool);
  });
}

function ensureNestedButtonsForTool() {
  const lp = document.getElementById("leftPanel");
  if (!lp) return;

  // wipe old rows and rebuild under their tool buttons
  lpRemoveOldOptionRows();

  // Find tool buttons in left panel
  const gutterBtn = document.getElementById("tool-line");
  const dsBtn = document.getElementById("tool-downspout");
  const coversBtn = document.getElementById("tool-covers");

  // Gutter options (Lower/Upper)
  if (gutterBtn) {
    const gGroup = makeOptGroup(
      [{ label: "Lower", value: "lower" }, { label: "Upper", value: "upper" }],
      () => (gutterLevel || "lower"),
      (v) => { gutterLevel = v; }
    );
    gGroup.setAttribute("data-tool", "line");
    gutterBtn.insertAdjacentElement("afterend", gGroup);
  }

  // Downspout options (2x3/3x4)
  if (dsBtn) {
    const dGroup = makeOptGroup(
      [{ label: "2x3", value: "2x3" }, { label: "3x4", value: "3x4" }],
      () => (downspoutType || "2x3"),
      (v) => { downspoutType = v; }
    );
    dGroup.setAttribute("data-tool", "downspout");
    dsBtn.insertAdjacentElement("afterend", dGroup);
  }

  // Covers options (exclusive)
  if (coversBtn) {
    const cGroup = makeOptGroup(
      [
        { label: "T-Rex", value: "trex" },
        { label: "Double PRO", value: "doublepro" },
        { label: "Gutter Clean", value: "gutterclean" },
        { label: "Gutter Clean PRO", value: "guttercleanpro" }
      ],
      () => {
        if (tool === "gutterclean") return "gutterclean";
        if (tool === "guttercleanpro") return "guttercleanpro";
        // covers tool uses coverType
        if (tool === "covers") {
        if (coverType === "Double PRO") return "doublepro";
        return "trex";
      }
        return null;
      },
      (v) => {
        if (v === "trex") { coverType = "T-Rex"; setTool("covers"); }
        else if (v === "doublepro") { coverType = "Double PRO"; setTool("covers"); }
        else if (v === "gutterclean") { setTool("gutterclean"); }
        else if (v === "guttercleanpro") { setTool("guttercleanpro"); }
      }
    );
    cGroup.setAttribute("data-tool", "covers");
    coversBtn.insertAdjacentElement("afterend", cGroup);
  }

  // Only the active tool's group should be expanded
  setExpandedToolOptions(tool);
}




function openInfoPanel() {
  // Default panel: Customer Info. Opening it closes Inventory.
  const inv = document.getElementById("inventoryPanel");
  if (inv) inv.classList.remove("open");

  const panel = document.getElementById("infoPanel");
  if (panel) panel.classList.add("open");
    try{ if (panelId === "settingsPanel") renderCurrentPriceList(); }catch(_){ }
  syncInfoPanelFromState();
  syncProjectInfoPanelFromState();
  buildColorDropdownUI();
  buildColorDropdownUI();
}
function closeInfoPanel() {
  const panel = document.getElementById("infoPanel");
  if (panel) panel.classList.remove("open");
}

/* ---------- SETTINGS PANEL ---------- */
function openSettingsPanel() {
  const p = document.getElementById("settingsPanel");
  if (p) p.classList.add("open");
}
function closeSettingsPanel() {
  const p = document.getElementById("settingsPanel");
  if (p) p.classList.remove("open");
}
function toggleSettingsPanel() {
  const p = document.getElementById("settingsPanel");
  if (!p) return;
  p.classList.toggle("open");
}

/* ---------- RIGHT PANEL EXCLUSIVITY ---------- */
function closeAllRightPanels() {
  ["infoPanel","inventoryPanel","settingsPanel"].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.remove("open");
  });
}
function openRightPanel(id) {
  closeAllRightPanels();
  const el = document.getElementById(id);
  if (el) el.classList.add("open");
}
function closeRightPanel(id) {
  const el = document.getElementById(id);
  if (el) el.classList.remove("open");
}
function toggleRightPanel(id) {
  const el = document.getElementById(id);
  if (!el) return;
  const willOpen = !el.classList.contains("open");
  closeAllRightPanels();
  if (willOpen) el.classList.add("open");
}

/* Backwards-compatible wrappers used by existing buttons */
function toggleInfoPanel() { toggleRightPanel("infoPanel"); }
function openInfoPanel() { openRightPanel("infoPanel"); }
function closeInfoPanel() { closeRightPanel("infoPanel"); }

function toggleInventory() { toggleRightPanel("inventoryPanel"); }
function openInventoryPanel() { openRightPanel("inventoryPanel"); }
function closeInventoryPanel() { closeRightPanel("inventoryPanel"); }

function toggleSettingsPanel() { toggleRightPanel("settingsPanel"); }
function openSettingsPanel() { openRightPanel("settingsPanel"); }
function closeSettingsPanel() { closeRightPanel("settingsPanel"); }


function toggleInfoPanel() {
  openInfoPanel();
}
function syncInfoPanelFromState() {
  const f = (id, val) => { const el = document.getElementById(id); if (el) el.value = val || ""; };
  f("ciFirst", customerInfo.firstName);
  f("ciLast", customerInfo.lastName);
  f("ciAddress", customerInfo.address);
  f("ciCity", customerInfo.city);
  f("ciZip", customerInfo.zip);
  f("ciPhone", customerInfo.phone);
  f("ciEmail", customerInfo.email);
}
function syncInfoStateFromPanel() {
  const g = (id) => { const el = document.getElementById(id); return el ? (el.value || "") : ""; };
  customerInfo = {
    firstName: g("ciFirst"),
    lastName: g("ciLast"),
    address: g("ciAddress"),
    city: g("ciCity"),
    zip: g("ciZip"),
    phone: g("ciPhone"),
    email: g("ciEmail")
  };
}


function syncProjectInfoPanelFromState() {
  const el = document.getElementById("piScheduleFor");
  if (el) el.value = (projectInfo && projectInfo.scheduleFor) ? projectInfo.scheduleFor : "";
  const p = document.getElementById("piProposal");
  if (p) p.value = (projectInfo && typeof projectInfo.proposal === "string") ? projectInfo.proposal : "";
}
function syncProjectInfoStateFromPanel() {
  const el = document.getElementById("piScheduleFor");
  const p = document.getElementById("piProposal");
  projectInfo = {
    scheduleFor: el ? (el.value || "") : "",
    proposal: p ? (p.value || "") : ""
  };
}




function toggleInventory() {
  if (!inventoryPanel) return;

  const info = document.getElementById("infoPanel");
  if (info) info.classList.remove("open");

  inventoryPanel.classList.toggle("open");
  updateInventory();
}
function hideInventory() {
  if (!inventoryPanel) return;
  inventoryPanel.classList.remove("open");
}

/* ---------- UNDO ---------- */
function ensureLineIds() {
  // Ensure every line has a stable id so other objects (like downspouts) can refer to it safely.
  for (const l of lines) {
    if (!l) continue;
    if (typeof l.id !== "number" || !isFinite(l.id)) {
      l.id = nextLineId++;
    } else {
      nextLineId = Math.max(nextLineId, l.id + 1);
    }
  }
}

function serializeState() {
  ensureLineIds();
  const state = {
    lines: lines.map(l => ({ ...l })),
    splashGuards: splashGuards.map(l => ({ ...l })),
    downspouts: downspouts.map(d => {
      if (!d) return null;
      const o = { ...d };
      o.lineId = (typeof o.lineId === "number") ? o.lineId : (d.line && typeof d.line.id === "number" ? d.line.id : null);
      delete o.line; // prevent embedding whole line object (avoids dangling refs after undo/redo)
      return o;
    }).filter(Boolean),
    texts: texts.map(t => ({ ...t })),
    doors: doors.map(d => ({ ...d })),
    gridSize, feetAcross,
    gutterColorName, downspoutColorName
,
    coverTRexLineIds: Array.from(coverTRexLineIds || []),
    coverDoubleProLineIds: Array.from(coverDoubleProLineIds || []),
    pvcWedgesLineIds: Array.from(pvcWedgesLineIds || []),
    pvcAddBoardLineIds: Array.from(pvcAddBoardLineIds || [])
  };
  return state;
}

function serializeProject() {
  // Full project snapshot for Save/Load (includes view + label toggles)
  const s = serializeState();
  return {
    appVersion: APP_VERSION,
    savedAt: new Date().toISOString(),
    nextLineId,
    nextSplashId,
    panX,
    panY,
    labelSize,
    showLabels,
    customerInfo,
    projectInfo,
    cornerIOToggles: Object.fromEntries(cornerIOToggles),
    miscItems,
    ...s
  };
}

function restoreProject(p) {
  // Restore corner IC/OC toggles (optional)
  cornerIOToggles = new Map();
  if (p && p.cornerIOToggles && typeof p.cornerIOToggles === "object") {
    for (const [k, v] of Object.entries(p.cornerIOToggles)) {
      if (v === "IC" || v === "OC") cornerIOToggles.set(k, v);
    }
  }


  // Restore misc items (project snapshot)
  if (Array.isArray(proj?.miscItems)) {
    miscItems = proj.miscItems.map(it => ({ desc: String(it?.desc || "").trim(), price: Number(it?.price || 0) })).filter(it => it.desc);
  }

  // Accept either a direct project snapshot or an object containing {state: ...}
  const proj = (p && p.state && typeof p.state === "object") ? p.state : p;
  if (!proj || typeof proj !== "object") return;

  restoreState(proj);

  // Restore view + label prefs (not part of undo state)
  if (typeof proj.panX === "number") panX = proj.panX;
  if (typeof proj.panY === "number") panY = proj.panY;
  if (typeof proj.labelSize === "number") labelSize = proj.labelSize;
  if (typeof proj.showLabels === "boolean") showLabels = proj.showLabels;
  if (proj.customerInfo && typeof proj.customerInfo === "object") {
    customerInfo = { ...customerInfo, ...proj.customerInfo };
  }
  if (proj.projectInfo && typeof proj.projectInfo === "object") {
    projectInfo = { ...projectInfo, ...proj.projectInfo };
  }

  // Restore id counter (or recompute)
  if (typeof proj.nextLineId === "number") nextLineId = proj.nextLineId;
  else {
    let mx = 0;
    for (const l of lines) if (l && typeof l.id === "number" && l.id > mx) mx = l.id;
    nextLineId = mx + 1;
  }

  // Sync UI
  const ls = document.getElementById("labelSizeSlider");
  if (ls) ls.value = String(Math.round(labelSize));
  redraw();
}




/* ---------- PROJECT FOLDER (File System Access API) ----------
   Lets you save project .json files into a real folder on disk:
   <selected version folder>/Projects/*.json

   Notes:
   - Requires a secure context in Chrome/Edge (https:// or http://localhost).
   - If unavailable/denied, Save falls back to normal download behavior.
*/
let projectRootDirHandle = null; // user-selected version folder (e.g., v7.1.0)

function hasFSAccessAPI() {
  return typeof window.showDirectoryPicker === "function" &&
         typeof window.showOpenFilePicker === "function";
}

function idbOpen() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open("gutter_app_db", 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains("kv")) db.createObjectStore("kv");
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}

async function idbSet(key, val) {
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction("kv", "readwrite");
    tx.objectStore("kv").put(val, key);
    tx.oncomplete = () => { db.close(); resolve(); };
    tx.onerror = () => { const e = tx.error; db.close(); reject(e); };
  });
}

async function idbGet(key) {
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction("kv", "readonly");
    const req = tx.objectStore("kv").get(key);
    req.onsuccess = () => { const v = req.result; db.close(); resolve(v); };
    req.onerror = () => { const e = req.error; db.close(); reject(e); };
  });
}

async function restoreProjectFolderHandle() {
  try {
    if (!hasFSAccessAPI()) return;
    const h = await idbGet("projectRootDirHandle");
    if (!h) return;

    // Verify permission if possible
    if (typeof h.queryPermission === "function") {
      const perm = await h.queryPermission({ mode: "readwrite" });
      if (perm !== "granted") return;
    }
    projectRootDirHandle = h;
  } catch (_) {
    projectRootDirHandle = null;
  }
}

async function ensureProjectsDir() {
  if (!projectRootDirHandle) return null;
  return await projectRootDirHandle.getDirectoryHandle("Projects", { create: true });
}

async function setProjectFolder() {
  try {
    if (!hasFSAccessAPI()) {
      alert("This browser does not support saving into a folder. Use Chrome/Edge on https:// or http://localhost.");
      return;
    }

    const handle = await window.showDirectoryPicker({ mode: "readwrite" });
    projectRootDirHandle = handle;

    // Persist handle for this browser + origin
    try { await idbSet("projectRootDirHandle", handle); } catch (_) {}

    // Create Projects/ folder
    await ensureProjectsDir();

    alert('Project folder set. Project JSON will save into: "Projects" inside the selected folder.');
  } catch (e) {
    // User cancelled or permission denied
    // Keep silent (no breaking behavior)
  }
}

/* Optional: load a project JSON from Projects/ folder */
async function loadProjectFromFolder() {
  try {
    if (!hasFSAccessAPI() || !projectRootDirHandle) {
      alert("Set Project Folder first (and use Chrome/Edge on https:// or http://localhost).");
      return;
    }
    const projectsDir = await ensureProjectsDir();
    const [fileHandle] = await window.showOpenFilePicker({
      multiple: false,
      startIn: projectsDir,
      types: [{ description: "Project JSON", accept: { "application/json": [".json"] } }]
    });
    const file = await fileHandle.getFile();
    const text = await file.text();
    const obj = JSON.parse(text);
    saveState(); // allow undo back
    restoreProject(obj);
  } catch (e) {
    // cancelled / invalid file / etc.
  }
}




/* ---------- TOAST (non-blocking notifications) ---------- */
function showToast(message, ms = 1800) {
  const container = document.getElementById("toastContainer");
  if (!container) return;

  const t = document.createElement("div");
  t.className = "toast";
  t.textContent = message;

  container.appendChild(t);

  // Trigger transition
  requestAnimationFrame(() => t.classList.add("show"));

  // Auto-hide
  setTimeout(() => {
    t.classList.remove("show");
    setTimeout(() => t.remove(), 220);
  }, ms);
}





function requireNameOrToast() {
  // Customer Info inputs (actual IDs in this app)
  const fnEl = document.getElementById("ciFirst");
  const lnEl = document.getElementById("ciLast");

  const fn = (fnEl?.value || "").trim();
  const ln = (lnEl?.value || "").trim();

  // clear previous error state
  if (fnEl) fnEl.classList.remove("req-error");
  if (lnEl) lnEl.classList.remove("req-error");

  let ok = true;
  if (!fn && fnEl) { fnEl.classList.add("req-error"); ok = false; }
  if (!ln && lnEl) { lnEl.classList.add("req-error"); ok = false; }

  if (!ok) {
    if (typeof showToast === "function") {
      showToast("Please enter First and Last Name before saving or exporting");
    } else {
      alert("Please enter First and Last Name before saving or exporting");
    }

    // Open Customer panel to guide user (force: close other right panels first)
    try {
      ["inventoryPanel","settingsPanel","infoPanel"].forEach(pid => {
        const p = document.getElementById(pid);
        if (p) p.classList.remove("open");
      });
      const info = document.getElementById("infoPanel");
      if (info) info.classList.add("open");
      if (typeof updateZoomDock === "function") updateZoomDock();
    } catch(e){}

    // focus first missing field
    setTimeout(() => {
      if (!fn && fnEl) fnEl.focus();
      else if (!ln && lnEl) lnEl.focus();
    }, 0);

    return false;
  }
  return true;
}





async function saveProjectJSON() {
  if (!requireNameOrToast()) return;
  if (typeof syncInfoStateFromPanel === "function") syncInfoStateFromPanel();
  if (typeof syncProjectInfoStateFromPanel === "function") syncProjectInfoStateFromPanel();

  const data = serializeProject();

  const fn = (customerInfo?.firstName || "").trim();
  const ln = (customerInfo?.lastName || "").trim();

  const safe = s =>
    String(s || "").normalize("NFKD")
      .replace(/[^A-Za-z0-9]+/g, "_")
      .replace(/^_+|_+$/g, "");

  const base =
    (safe(fn) && safe(ln))
      ? safe(fn) + "_" + safe(ln)
      : (safe(fn) || safe(ln) || "estimate");

  const fileName = base + ".json";
  const jsonText = JSON.stringify(data, null, 2);

  // Preferred: Save into selected folder/Projects using File System Access API
  try {
    if (projectRootDirHandle && hasFSAccessAPI()) {
      const projectsDir = await ensureProjectsDir();
      if (projectsDir) {
        const fileHandle = await projectsDir.getFileHandle(fileName, { create: true });
        const writable = await fileHandle.createWritable();
        await writable.write(jsonText);
        await writable.close();

        showToast('Project saved:\nProjects/' + fileName);
        return;
      }
    }
  } catch (_) {
    // fall back to download below
  }

  // Fallback: normal download
  const blob = new Blob([jsonText], { type: "application/json" });
  const a = document.createElement("a");
  a.download = "Projects/" + fileName;
  a.href = URL.createObjectURL(blob);
  document.body.appendChild(a);
  a.click();
  URL.revokeObjectURL(a.href);
  a.remove();

  showToast('Project downloaded:\n' + fileName);
}





function triggerLoadProject() {
  const inp = document.getElementById("projectFileInput");
  if (inp) inp.click();
}

function handleProjectFileSelected(file) {
  if (!file) return;
  const reader = new FileReader();
  reader.onload = () => {
    try {
      const obj = JSON.parse(String(reader.result || ""));
      saveState(); // allow undo back to previous state
      restoreProject(obj);
    } catch (e) {
      alert("Could not load file. Make sure it's a valid project .json");
    }
  };
  reader.readAsText(file);
}



function restoreState(state) {

  lines = Array.isArray(state.lines) ? state.lines : [];
  ensureLineIds();

  splashGuards = Array.isArray(state.splashGuards) ? state.splashGuards : [];
  // ensure unique splash ids
  if (splashGuards.length) {
    let maxId = 0;
    splashGuards.forEach(l => { if (l && typeof l.id === "number") maxId = Math.max(maxId, l.id); });
    nextSplashId = Math.max(nextSplashId, maxId + 1);
  }

  const idMap = new Map();
  lines.forEach(l => idMap.set(l.id, l));

  // Restore cover/PVC selection sets (filter to existing line ids)
  coverTRexLineIds = new Set((state.coverTRexLineIds || []).filter(id => idMap.has(id)));
  coverDoubleProLineIds = new Set((state.coverDoubleProLineIds || []).filter(id => idMap.has(id)));
  pvcWedgesLineIds = new Set((state.pvcWedgesLineIds || []).filter(id => idMap.has(id)));
  pvcAddBoardLineIds = new Set((state.pvcAddBoardLineIds || []).filter(id => idMap.has(id)));


  downspouts = (Array.isArray(state.downspouts) ? state.downspouts : []).map(d => {
    if (!d) return null;
    const o = { ...d };
    // attach by id (primary)
    if (typeof o.lineId === "number" && idMap.has(o.lineId)) {
      o.line = idMap.get(o.lineId);
    } else {
      o.line = null;
    }
    if (typeof o.qty !== "number" || !isFinite(o.qty)) o.qty = dsQtyDefaultForLine(o.line);
    else o.qty = Math.max(1, Math.min(4, Math.round(o.qty)));
    return o;
  }).filter(Boolean);

  texts = Array.isArray(state.texts) ? state.texts : [];
  doors = Array.isArray(state.doors) ? state.doors : [];
  gridSize = (typeof state.gridSize === "number") ? state.gridSize : 1;
  feetAcross = (typeof state.feetAcross === "number") ? state.feetAcross : feetAcross;

  gutterColorName = (typeof state.gutterColorName === "string") ? state.gutterColorName : gutterColorName;
  downspoutColorName = (typeof state.downspoutColorName === "string") ? state.downspoutColorName : downspoutColorName;

  cleanDownspouts();
  autoCorners();
  enforceExclusiveCovers();
  redraw();
}

function saveState() {
  undoStack.push(JSON.stringify(serializeState()));
  redoStack = [];
}

function loadState(state) {
  let s = JSON.parse(state);

  // Use unified restore so attachments (downspouts->lines) remain valid.
  restoreState({
    lines: s.lines || [],
    downspouts: s.downspouts || [],
    texts: s.texts || [],
    doors: s.doors || [],
    gridSize: s.gridSize,
    feetAcross: s.feetAcross,
    gutterColorName: s.gutterColorName,
    downspoutColorName: s.downspoutColorName
  });

  // restore dropdown colors
  if (gutterColorSelect) gutterColorSelect.value = gutterColorName;
  if (downspoutColorSelect) downspoutColorSelect.value = downspoutColorName;
}
function undo() {
  if (!undoStack.length) return;
  redoStack.push(JSON.stringify(serializeState()));
  const state = JSON.parse(undoStack.pop());
  restoreState(state);
}
function redo() {
  if (!redoStack.length) return;
  undoStack.push(JSON.stringify(serializeState()));
  const state = JSON.parse(redoStack.pop());
  restoreState(state);
}

/* ---------- SETUP ---------- */
function updatePanelOffsets() {
  const toolbar = document.getElementById("toolbar");
  const lp = document.getElementById("leftPanel");
  if (!toolbar || !lp) return;
  const h = toolbar.offsetHeight || 0;
  lp.style.top = h + "px";
  lp.style.height = Math.max(0, window.innerHeight - h) + "px";
}

function resizeCanvas() {
  const toolbarEl = document.getElementById("toolbar");
  const h = toolbarEl ? (toolbarEl.offsetHeight || 0) : 0;

  // Pin canvas directly under the toolbar (prevents any layout gap)
  canvas.style.position = "fixed";
  canvas.style.left = "0";
  canvas.style.top = h + "px";
  canvas.style.width = "100vw";
  canvas.style.height = Math.max(0, window.innerHeight - h) + "px";

  // Match drawing buffer to display size
  canvas.width = window.innerWidth;
  canvas.height = Math.max(0, window.innerHeight - h);

  gridSize = canvas.width / feetAcross;
  redraw();
  updatePanelOffsets();
}
window.addEventListener("resize", resizeCanvas);
resizeCanvas();

// Ensure inventory is populated on load
updateInventory();

function setTool(t) {
  // If Gutter Clean PRO upgrade is accepted, force "gutterclean" to draw as PRO
  try{ if (t === "gutterclean" && window.__UPG_GCP_ALL) t = "guttercleanpro"; }catch(_){ }
  tool = t;
  if (t === "covers") {
    if (!coverType) {
      coverType = "T-Rex";
      if (typeof coversSelect !== "undefined" && coversSelect) coversSelect.value = "T-Rex";
    }
  }
  hoverPVCLineIds = null;
  hoverSelect = null;
  hoverDelete = null;
  hoverLineLabel = null;

  document.querySelectorAll(".tool-btn").forEach(b => b.classList.remove("active"));
  const btnId = (t === "gutterclean" || t === "guttercleanpro") ? "tool-covers" : ("tool-" + t);
  const btn = document.getElementById(btnId);
  if (btn) btn.classList.add("active");

  updateInjectedVisibility();
  ensureNestedButtonsForTool();
  setExpandedToolOptions(tool);

  // --- Robust tool button highlighting (prevents accidental 'eraser' confusion) ---
  const toolIds = [
    "tool-line","tool-splash","tool-downspout","tool-covers","tool-door","tool-text","tool-moveSection",
    "tool-select","tool-eraser",
    "tool-2x3","tool-3x4"
  ];
  toolIds.forEach(id => {
    const el = document.getElementById(id);
    if (el) el.classList.remove("active");
  });

  const map = {
    line: "tool-line",
    splash: "tool-splash",
    downspout: "tool-downspout",
    covers: "tool-covers",
    pvc: "tool-pvc",
    door: "tool-door",
    text: "tool-text",
    moveSection: "tool-moveSection",
    select: "tool-select",
    eraser: "tool-eraser"
  };
  const activeId = map[t];
  if (activeId) {
    const el = document.getElementById(activeId);
    if (el) el.classList.add("active");
  }

}




function setColor(c) {
  currentColor = c;
  document.querySelectorAll(".color-btn").forEach(b => b.classList.remove("active"));
  document.getElementById("color-" + c).classList.add("active");
}

function setScale(v) {
  feetAcross = parseInt(v);
  gridSize = canvas.width / feetAcross;
  snapAll();
  redraw();
}

function setLabelSize(v) {
  labelSize = parseInt(v);
  redraw();
}

function snap(v) { return Math.round(v / gridSize) * gridSize; }

function snapToEndpoint(x, y) {
  for (let l of lines) {
    let pts = [[l.x1, l.y1], [l.x2, l.y2]];
    for (let p of pts) {
      if (Math.hypot(x - p[0], y - p[1]) < SNAP_RADIUS) {
        return { x: p[0], y: p[1] };
      }
    }
  }
  return null;
  for (let l of splashGuards) {
    let pts = [[l.x1, l.y1], [l.x2, l.y2]];
    for (let p of pts) {
      if (Math.hypot(x - p[0], y - p[1]) < SNAP_RADIUS) {
        return { x: p[0], y: p[1] };
      }
    }
  }

}

function snapAll() {
  lines.forEach(l => {
    l.x1 = snap(l.x1); l.y1 = snap(l.y1);
    l.x2 = snap(l.x2); l.y2 = snap(l.y2);
  });
  splashGuards.forEach(l => {
    l.x1 = snap(l.x1); l.y1 = snap(l.y1);
    l.x2 = snap(l.x2); l.y2 = snap(l.y2);
  });
  texts.forEach(t => { t.x = snap(t.x); t.y = snap(t.y); });
  doors.forEach(d => { d.x = snap(d.x); d.y = snap(d.y); });
}


function endpointKey(x, y) {
  return Math.round(x / gridSize) + "," + Math.round(y / gridSize);
}

function connectedSectionFromLineId(lineId) {
  const byEp = new Map(); // ep -> [lineId]
  const adj = new Map();  // lineId -> Set(lineId)

  for (const l of lines) {
    if (!l || typeof l.id !== "number") continue;
    adj.set(l.id, new Set());
    const a = endpointKey(l.x1, l.y1);
    const b = endpointKey(l.x2, l.y2);
    if (!byEp.has(a)) byEp.set(a, []);
    if (!byEp.has(b)) byEp.set(b, []);
    byEp.get(a).push(l.id);
    byEp.get(b).push(l.id);
  }

function sectionKeyFromLineIdSet(idSet) {
  if (!idSet) return "";
  const arr = Array.from(idSet).slice().sort((a,b)=>a-b);
  return arr.join(",");
}


  for (const ids of byEp.values()) {
    for (let i = 0; i < ids.length; i++) {
      for (let j = i + 1; j < ids.length; j++) {
        adj.get(ids[i]).add(ids[j]);
        adj.get(ids[j]).add(ids[i]);
      }
    }
  }

  if (!adj.has(lineId)) return null;
  const visited = new Set([lineId]);
  const stack = [lineId];
  while (stack.length) {
    const cur = stack.pop();
    for (const nb of adj.get(cur)) {
      if (!visited.has(nb)) { visited.add(nb); stack.push(nb); }
    }
  }
  return visited;
}

function computeMoveSectionSelectionFromLineId(lineId) {
  const ids = connectedSectionFromLineId(lineId);
  if (!ids) return null;
  const doorIdxs = new Set();
  for (let di = 0; di < doors.length; di++) {
    const d = doors[di];
    if (!d) continue;
    let attached = false;
    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (!ids.has(l.id)) continue;
      const p = project(d.x, d.y, l);
      if (p.dist < 16) { attached = true; break; }
    }
    if (attached) doorIdxs.add(di);
  }
  return { lineIds: ids, doorIdxs };
}

function clearMoveSectionSelection() {
  moveSectionState.lineIds = null;
  moveSectionState.doorIdxs = null;
  moveSectionState.dragging = false;
  moveSectionState.start = null;
  moveSectionState.lineStarts = null;
  moveSectionState.doorStarts = null;
}

function toWorld(x, y) { return { x: x - panX, y: y - panY }; }

/* ---------- FIT TO SCREEN ---------- */
function getSceneBounds() {
  cleanDownspouts();
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

  function includePoint(x, y) {
    if (x < minX) minX = x;
    if (y < minY) minY = y;
    if (x > maxX) maxX = x;
    if (y > maxY) maxY = y;
  }
  function includeRect(x1, y1, x2, y2) {
    includePoint(x1, y1);
    includePoint(x2, y2);
  }

  ctx.save();
  ctx.font = labelSize + "px Arial";

  for (const l of lines) {
    includePoint(l.x1, l.y1);
    includePoint(l.x2, l.y2);

    // Include gutter length label (with user drag offsets)
    const b = lineLabelBox(l);
    includeRect(b.x1, b.y1, b.x2, b.y2);
  }

  for (const d of downspouts) {
    if (!d || !d.line) continue;
    const l = d.line;
    if (!l) continue;

    const x = l.x1 + (l.x2 - l.x1) * d.offset;
    const y = l.y1 + (l.y2 - l.y1) * d.offset;

    includeRect(x - DS_RADIUS, y - DS_RADIUS, x + DS_RADIUS, y + DS_RADIUS);

    // Include DS label (with flip + user drag offsets)
    const b = dsLabelBox(d);
    includeRect(b.x1, b.y1, b.x2, b.y2);
  }

  for (const d of doors) {
    const b = doorBounds(d);
    includeRect(b.x1, b.y1, b.x2, b.y2);
  }

  for (const t of texts) {
    const w = ctx.measureText(t.text).width;
    includeRect(t.x, t.y - labelSize, t.x + w, t.y + 4);
  }

  ctx.restore();

  if (minX === Infinity) return null;

  if (maxX - minX < 1) maxX = minX + 1;
  if (maxY - minY < 1) maxY = minY + 1;

  return { minX, minY, maxX, maxY, width: maxX - minX, height: maxY - minY };
}

function scaleWorld(f) {
  for (const l of lines) {
    l.x1 *= f; l.y1 *= f;
    l.x2 *= f; l.y2 *= f;
    if (typeof l.labelDx === "number") l.labelDx *= f;
    if (typeof l.labelDy === "number") l.labelDy *= f;
  }
for (const t of texts) { t.x *= f; t.y *= f; }
  for (const d of doors) { d.x *= f; d.y *= f; }

  // Scale splash guards (world-space segments)
  for (const sg of splashGuards) {
    sg.x1 *= f; sg.y1 *= f;
    sg.x2 *= f; sg.y2 *= f;
  }

  // Scale downspout label offsets (positions are derived from gutter lines via offset)
  for (const ds of downspouts) {
    if (typeof ds.labelDx === "number") ds.labelDx *= f;
    if (typeof ds.labelDy === "number") ds.labelDy *= f;
  }

  gridSize *= f;
  labelSize *= f;
  feetAcross = canvas.width / gridSize;
}

function fitToScreen() {
  const b = getSceneBounds();
  const leftPanel = document.getElementById("leftPanel");
  const toolbar = document.getElementById("toolbar");

  const infoPanel = document.getElementById("infoPanel");
  const invPanel = document.getElementById("inventoryPanel");

  const leftInset = leftPanel ? leftPanel.offsetWidth : 0;
  const topInset = toolbar ? toolbar.offsetHeight : 0;

  // If either right-side panel is open, reserve that width too
  let rightInset = 0;
  if (infoPanel && infoPanel.classList.contains("open")) rightInset = infoPanel.offsetWidth || 0;
  else if (invPanel && invPanel.classList.contains("open")) rightInset = invPanel.offsetWidth || 0;

  if (!b) {
    panX = leftInset;
    panY = topInset;
    redraw();
    return;
  }

  const pad = Math.max(40, labelSize * 1.6);
  const availW = Math.max(10, (canvas.width - leftInset - rightInset) - pad * 2);
  const availH = Math.max(10, (canvas.height - topInset) - pad * 2);

  const scale = Math.min(availW / b.width, availH / b.height);
  if (!isFinite(scale) || scale <= 0) return;

  scaleWorld(scale);
  autoCorners();

  const minX = b.minX * scale;
  const minY = b.minY * scale;
  const width = b.width * scale;
  const height = b.height * scale;

  const extraX = ((canvas.width - leftInset - rightInset) - pad * 2) - width;
  const extraY = ((canvas.height - topInset) - pad * 2) - height;

  panX = leftInset + pad - minX + extraX / 2;
  panY = topInset + pad - minY + extraY / 2;

  snapAll();
  cleanDownspouts();
  autoCorners();
  redraw();
}

/* ---------- EVENTS ---------- */
canvas.addEventListener("dblclick", e => {
  // Double-click is ONLY for editing text labels.
  // It should never delete doors or other objects.
  if (tool !== "select") return;

  const r = canvas.getBoundingClientRect();
  const mx = e.clientX - r.left, my = e.clientY - r.top;
  const pt = toWorld(mx, my);
  const x = pt.x, y = pt.y;

  ctx.save();
  ctx.font = labelSize + "px Arial";

  for (const t of texts) {
    const w = ctx.measureText(t.text).width;
    if (x > t.x && x < t.x + w && y < t.y && y > t.y - labelSize) {
      const newText = prompt("Edit text:", t.text);
      if (newText !== null) {
        saveState();
        t.text = newText;
        redraw();
      }
      ctx.restore();
      return;
    }
  }

  ctx.restore();
});

// Zoom with mouse wheel / trackpad scroll (zoom around cursor)
canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;

  const zoomIn = e.deltaY < 0;
  const f = zoomIn ? 1.1 : 0.9;

  // Keep the world point under cursor anchored
  const worldX = mx - panX;
  const worldY = my - panY;

  saveState();
  scaleWorld(f);
  autoCorners();

  panX = mx - worldX * f;
  panY = my - worldY * f;

  redraw();
}, { passive: false });

canvas.addEventListener("pointerdown", e => {
  // Mobile/touch support via Pointer Events
  if (e.pointerType === "touch") e.preventDefault();
  if (e.isPrimary === false) return;
  try { canvas.setPointerCapture(e.pointerId); } catch (err) {}
  isPrimaryPointerDown = true;


  // Shift + click with Selector performs Move Section (select connected section then drag to move).
  // This keeps the UI simple and avoids a separate tool mode.
  if (tool === "select" && e.shiftKey) {
    const r0 = canvas.getBoundingClientRect();
    const mx0 = e.clientX - r0.left, my0 = e.clientY - r0.top;
    const pt0 = toWorld(mx0, my0);
    const x0 = pt0.x, y0 = pt0.y;

    // If no section is selected yet, pick the nearest line under cursor.
    if (!moveSectionState.lineIds) {
      let best = null, bestLine = null;
      for (const l of lines) {
        if (!l) continue;
        const p = project(x0, y0, l);
        if (p.dist < 8 && (best === null || p.dist < best)) { best = p.dist; bestLine = l; }
      }
      if (bestLine && typeof bestLine.id === "number") {
        const sel = computeMoveSectionSelectionFromLineId(bestLine.id);
        if (sel) {
          moveSectionState.lineIds = sel.lineIds;
          moveSectionState.doorIdxs = sel.doorIdxs;
        }
      } else {
        clearMoveSectionSelection();
      }
      redraw();
      return;
    }

    // Start drag (click anywhere once selected)
    saveState();
    moveSectionState.dragging = true;
    moveSectionState.start = { x: x0, y: y0 };
    moveSectionState.lineStarts = new Map();
    moveSectionState.doorStarts = new Map();
    moveSectionState.cornerStarts = new Map();

    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (!moveSectionState.lineIds.has(l.id)) continue;
      moveSectionState.lineStarts.set(l.id, { x1: l.x1, y1: l.y1, x2: l.x2, y2: l.y2 });
    }
    for (const di of (moveSectionState.doorIdxs || [])) {
      const d = doors[di];
      if (d) moveSectionState.doorStarts.set(di, { x: d.x, y: d.y });
    }

    // Capture starting positions of corners that belong to the selected section (match original endpoints).
    const eps = 1;
    for (let ci = 0; ci < corners.length; ci++) {
      const c = corners[ci];
      if (!c) continue;
      let belongs = false;
      for (const [lid, s] of moveSectionState.lineStarts.entries()) {
        if (!moveSectionState.lineIds || !moveSectionState.lineIds.has(lid)) continue;
        if ((Math.abs(c.x - s.x1) < eps && Math.abs(c.y - s.y1) < eps) ||
            (Math.abs(c.x - s.x2) < eps && Math.abs(c.y - s.y2) < eps)) {
          belongs = true;
          break;
        }
      }
      if (belongs) moveSectionState.cornerStarts.set(ci, { x: c.x, y: c.y });
    }

    return;
  }


  // Selector: click a corner to toggle IC/OC label
  if (tool === "select" && corners && corners.length) {
    const r = canvas.getBoundingClientRect();
    const mx = e.clientX - r.left, my = e.clientY - r.top;
    const pt = toWorld(mx, my);
    for (const c of corners) {
      if (!c) continue;
      if (Math.hypot(pt.x - c.x, pt.y - c.y) <= 12) {
        toggleCornerIOAt(c.x, c.y);
        redraw();
        return;
      }
    }
  }


  // Guard: in Select tool, ignore the second click of a double-click (prevents accidental deletes)
  if (tool === "select" && e.detail && e.detail > 1) {
    return;
  }
  let r = canvas.getBoundingClientRect();
  let mx = e.clientX - r.left, my = e.clientY - r.top;
  let { x, y } = toWorld(mx, my);

  ctx.font = labelSize + "px Arial";

  let ep = snapToEndpoint(x, y);
  if (ep) { x = ep.x; y = ep.y; }
  else { x = snap(x); y = snap(y); }

  // Covers click toggle (T-Rex): toggle dotted cover on connected gutter section
  
  if (tool === "covers" && coverType === "T-Rex" && hoverCoverLineIds && hoverCoverLineIds.size) {
    saveState();

    // If the whole section is already T-Rex covered, remove it; otherwise apply T-Rex AND remove Double PRO on same section.
    let allCovered = true;
    for (const id of hoverCoverLineIds) {
      if (!coverTRexLineIds.has(id)) { allCovered = false; break; }
    }

    if (allCovered) {
      for (const id of hoverCoverLineIds) coverTRexLineIds.delete(id);
    } else {
      for (const id of hoverCoverLineIds) {
        coverTRexLineIds.add(id);
        // mutually exclusive: remove Double PRO on these lines
        if (coverDoubleProLineIds) coverDoubleProLineIds.delete(id);
      }
    }

    updateInventory();
    redraw();
    return;
  }


  // Covers click toggle (Double PRO): toggle dashed cover on connected gutter section
  
  if (tool === "covers" && coverType === "Double PRO" && hoverCoverLineIds && hoverCoverLineIds.size) {
    saveState();

    // If the whole section is already Double PRO covered, remove it; otherwise apply Double PRO AND remove T-Rex on same section.
    let allCovered = true;
    for (const id of hoverCoverLineIds) {
      if (!coverDoubleProLineIds.has(id)) { allCovered = false; break; }
    }

    if (allCovered) {
      for (const id of hoverCoverLineIds) coverDoubleProLineIds.delete(id);
    } else {
      for (const id of hoverCoverLineIds) {
        coverDoubleProLineIds.add(id);
        // mutually exclusive: remove T-Rex on these lines
        if (coverTRexLineIds) coverTRexLineIds.delete(id);
      }
    }

    updateInventory();
    redraw();
    return;
  }


  // PVC click toggle (Wedges / Add-A-Board): toggle selection on connected gutter section under hover
  if (tool === "pvc" && (pvcType === "wedges" || pvcType === "addaboard") && hoverPVCLineIds && hoverPVCLineIds.size) {
    saveState();

    const targetSet = (pvcType === "wedges") ? pvcWedgesLineIds : pvcAddBoardLineIds;
    const otherSet  = (pvcType === "wedges") ? pvcAddBoardLineIds : pvcWedgesLineIds;

    let allApplied = true;
    for (const id of hoverPVCLineIds) {
      if (!targetSet.has(id)) { allApplied = false; break; }
    }

    if (allApplied) {
      for (const id of hoverPVCLineIds) targetSet.delete(id);
      if (typeof showToast === "function") showToast(pvcType === "wedges" ? "PVC Wedges removed" : "Add-A-Board removed");
    } else {
      for (const id of hoverPVCLineIds) {
        targetSet.add(id);
        if (otherSet) otherSet.delete(id);
      }
      if (typeof showToast === "function") showToast(pvcType === "wedges" ? "PVC Wedges applied" : "Add-A-Board applied");
    }

    updateInventory();
    redraw();
    return;
  }


  // Move Section tool: click a gutter line to select its connected section, then drag to move (snaps)
  if (tool === "moveSection") {
    if (!moveSectionState.lineIds) {
      let best = null, bestLine = null;
      for (const l of lines) {
        if (!l) continue;
        const p = project(x, y, l);
        if (p.dist < 8 && (best === null || p.dist < best)) { best = p.dist; bestLine = l; }
      }
      if (bestLine && typeof bestLine.id === "number") {
        const sel = computeMoveSectionSelectionFromLineId(bestLine.id);
        if (sel) {
          moveSectionState.lineIds = sel.lineIds;
          moveSectionState.doorIdxs = sel.doorIdxs;
        }
      } else {
        clearMoveSectionSelection();
      }
      redraw();
      return;
    }

    // Start drag (click anywhere once selected)
    saveState();
    moveSectionState.dragging = true;
    moveSectionState.start = { x, y };
    moveSectionState.lineStarts = new Map();
    moveSectionState.doorStarts = new Map();

    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (!moveSectionState.lineIds.has(l.id)) continue;
      moveSectionState.lineStarts.set(l.id, { x1: l.x1, y1: l.y1, x2: l.x2, y2: l.y2 }, { passive: false });
    }
    for (const di of moveSectionState.doorIdxs || []) {
      const d = doors[di];
      if (d) moveSectionState.doorStarts.set(di, { x: d.x, y: d.y });
    }
    return;
  }

  if (tool === "select" && (!hoverSelect || (hoverSelect.type !== "text" && hoverSelect.type !== "textResizeHandle"))) { selectedTextObj = null; }

  if (tool === "eraser" && hoverDelete) {
    const erBtn = document.getElementById("tool-eraser");
    if (erBtn && !erBtn.classList.contains("active")) { return; }
    saveState();if (hoverDelete.type === "line") {
      let deadLine = lines[hoverDelete.index];
      const deadSig = lineSig(deadLine);
      lines.splice(hoverDelete.index, 1);
      // Remove any downspouts attached to this gutter line (prefer id; fallback signature for legacy states).
const deadId = (deadLine && typeof deadLine.id === "number") ? deadLine.id : null;
downspouts = downspouts.filter(d => {
  if (!d) return false;
  const did = (typeof d.lineId === "number") ? d.lineId : (d.line && typeof d.line.id === "number" ? d.line.id : null);
  if (deadId !== null && did === deadId) return false;
  const ls = lineSig(d.line);
  return (d.line !== deadLine) && (ls !== deadSig);
});
cleanDownspouts();
    }
    if (hoverDelete.type === "downspout") downspouts.splice(hoverDelete.index, 1);
    if (hoverDelete.type === "text") texts.splice(hoverDelete.index, 1);
    if (hoverDelete.type === "door") doors.splice(hoverDelete.index, 1);
    if (hoverDelete.type === "splashLine") splashGuards.splice(hoverDelete.index, 1);
    autoCorners(); redraw(); return;
  }

  if (tool === "select" && hoverSelect) {
    // Selector interactions (drag things)
    if (hoverSelect.type === "endpoint" || hoverSelect.type === "splashEndpoint") {
      saveState();
      draggingPoint = hoverSelect;
      return;
    }

    if (hoverSelect.type === "linelabel" && showLabels) {
      saveState();
      draggingLineLabel = hoverSelect.line;
      labelDragStart = { x, y };
      if (typeof draggingLineLabel.labelDx !== "number") draggingLineLabel.labelDx = 0;
      if (typeof draggingLineLabel.labelDy !== "number") draggingLineLabel.labelDy = 0;
      textOffset.x = draggingLineLabel.labelDx;
      textOffset.y = draggingLineLabel.labelDy;
      return;
    }

    if (hoverSelect.type === "dslabel" && showLabels) {
      saveState();
      draggingDsLabel = hoverSelect.obj;
      dsLabelDragStart = { x, y };
      if (typeof draggingDsLabel.labelDx !== "number") draggingDsLabel.labelDx = 0;
      if (typeof draggingDsLabel.labelDy !== "number") draggingDsLabel.labelDy = 0;
      textOffset.x = draggingDsLabel.labelDx;
      textOffset.y = draggingDsLabel.labelDy;
      return;
    }

    if (hoverSelect.type === "textResizeHandle") {
      saveState();
      selectedTextObj = hoverSelect.obj;
      const t = selectedTextObj;
      const fs = (typeof t.size === "number" && isFinite(t.size)) ? t.size : labelSize;
      ctx.font = fs + "px Arial";
      const w = ctx.measureText(t.text || "").width;
      const anchorX = t.x;
      const anchorY = t.y;
      const hx = t.x + w + 3;
      const hy = t.y + 3;
      const startDist = Math.max(8, Math.hypot(hx - anchorX, hy - anchorY));
      draggingTextResize = { obj: t, anchorX, anchorY, startDist, startSize: fs };
      return;
    }

    if (hoverSelect.type === "text") {
      saveState();
      selectedTextObj = hoverSelect.obj;
      draggingText = hoverSelect.obj;
      textOffset.x = x - draggingText.x;
      textOffset.y = y - draggingText.y;
      return;
    }
if (hoverSelect.type === "door") {
      saveState();
      draggingDoor = hoverSelect.obj;
      doorOffset.x = x - draggingDoor.x;
      doorOffset.y = y - draggingDoor.y;
      doorClickStart = { x, y };
      doorClickMoved = false;
      return;
    }

    if (hoverSelect.type === "downspout") {
      // Click without drag will flip label on mouseup
      saveState();
      draggingDownspout = hoverSelect.obj;
      dsClickStart = { x, y };
      dsClickMoved = false;
      return;
    }

    if (hoverSelect.type === "line") {
      // Selector click on a gutter line:
      // - For Gutter Clean / Gutter Clean PRO: toggle level (L <-> U) for future differential pricing
      // - Otherwise: no drag behavior for whole line right now
      const l = lines[hoverSelect.index];
      if (l && (l.kind === "clean" || l.kind === "cleanpro")) {
        saveState();
        l.level = (l.level === "upper") ? "lower" : "upper";
        try { updateInventory(); } catch(_){}
        redraw();
      }
      return;
    }

    return;
  }

  if (tool === "select") {
    panning = true;
    panStart = { x: mx - panX, y: my - panY };
    return;
  }

  if (tool === "gutterclean") {
    drawingLine = { id: nextLineId++, x1: x, y1: y, x2: x, y2: y, color: "black", level: gutterLevel, kind: "clean" };
  }

  if (tool === "guttercleanpro") {
    drawingLine = { id: nextLineId++, x1: x, y1: y, x2: x, y2: y, color: "black", level: gutterLevel, kind: "cleanpro" };
  }

  if (tool === "line") {
    drawingLine = { id: nextLineId++, x1: x, y1: y, x2: x, y2: y, color: currentColor, level: gutterLevel, colorName: gutterColorName };
  }

  if (tool === "splash") {
    drawingSplash = { id: nextSplashId++, x1: x, y1: y, x2: x, y2: y };
  }

  if (tool === "text") {
    let str = prompt("Enter text:");
    if (str) { saveState(); texts.push({ x, y, text: str, color: currentColor, size: labelSize }); }
  }

  if (tool === "door") {
    saveState();
    doors.push({ x, y, wFeet: 3, rot: 0 });
  }

  // NEW: Downspout tool (single button) uses dropdown type
  if (tool === "downspout") {
    let best = null, bestLine = null, bestT = 0;
    for (let l of lines) {
      let p = project(x, y, l);
      if (p.dist < 8 && (best === null || p.dist < best)) {
        best = p.dist; bestLine = l; bestT = p.t;
      }
    }
    if (bestLine) {
      saveState();
      downspouts.push({ line: bestLine, lineId: (bestLine && typeof bestLine.id === "number") ? bestLine.id : null, offset: bestT, type: downspoutType, colorName: downspoutColorName, qty: dsQtyDefaultForLine(bestLine), labelDx: 0, labelDy: 0, labelFlip: false });
    }
  }

  redraw();
});

canvas.addEventListener("pointermove", e => {
  if (e.pointerType === "touch") e.preventDefault();
  if (e.isPrimary === false) return;

  let r = canvas.getBoundingClientRect();
  let mx = e.clientX - r.left, my = e.clientY - r.top;
  let { x, y } = toWorld(mx, my);

  // Covers hover compute (T-Rex): highlight connected gutter section under cursor
  if (tool === "covers" && (coverType === "T-Rex" || coverType === "Double PRO")) {
    let best = null, bestLine = null;
    for (const l of lines) {
      if (!l) continue;
      const p = project(x, y, l);
      if (p.dist < 10 && (best === null || p.dist < best)) { best = p.dist; bestLine = l; }
    }
    if (bestLine && typeof bestLine.id === "number") hoverCoverLineIds = connectedSectionFromLineId(bestLine.id);
    else hoverCoverLineIds = null;
    redraw();
    return;
  }



  

  // PVC hover compute: highlight connected gutter section under cursor (Wedges / Add-A-Board)
  if (tool === "pvc" && (pvcType === "wedges" || pvcType === "addaboard")) {
    try { if (typeof ensureLineIds === "function") ensureLineIds(); } catch(_){}
    let best = null, bestLine = null;
    for (const l of lines) {
      if (!l) continue;
      const p = project(x, y, l);
      if (p.dist < 10 && (best === null || p.dist < best)) { best = p.dist; bestLine = l; }
    }
    if (bestLine && typeof bestLine.id === "number") hoverPVCLineIds = connectedSectionFromLineId(bestLine.id);
    else hoverPVCLineIds = null;
    redraw();
    return;
  }

  // PVC hover compute (Step 2): highlight connected gutter section under cursor
  if (tool === "pvc" && (pvcType === "wedges" || pvcType === "addaboard")) {
    let best = null, bestLine = null;
    for (const l of lines) {
      if (!l) continue;
      const p = project(x, y, l);
      if (p.dist < 10 && (best === null || p.dist < best)) { best = p.dist; bestLine = l; }
    }
    if (bestLine && typeof bestLine.id === "number") hoverPVCLineIds = connectedSectionFromLineId(bestLine.id);
    else hoverPVCLineIds = null;
    redraw();
    return;
  } else {
    hoverPVCLineIds = null;
  }

// Move Section dragging (tool button OR Shift+Select)
  if ((tool === "moveSection" || tool === "select") && moveSectionState.dragging && moveSectionState.start) {
    const dx = x - moveSectionState.start.x;
    const dy = y - moveSectionState.start.y;

    for (const l of lines) {
      if (!l || typeof l.id !== "number") continue;
      if (!moveSectionState.lineIds || !moveSectionState.lineIds.has(l.id)) continue;
      const s = moveSectionState.lineStarts.get(l.id);
      if (!s) continue;
      l.x1 = snap(s.x1 + dx); l.y1 = snap(s.y1 + dy);
      l.x2 = snap(s.x2 + dx); l.y2 = snap(s.y2 + dy);
    }

    for (const di of (moveSectionState.doorIdxs || [])) {
      const d = doors[di];
      const s = moveSectionState.doorStarts.get(di);
      if (!d || !s) continue;
      d.x = snap(s.x + dx);
      d.y = snap(s.y + dy);
    }

        // move corners with live preview (non-cumulative)
    if (moveSectionState.cornerStarts) {
      for (const [ci, s] of moveSectionState.cornerStarts.entries()) {
        const c = corners[ci];
        if (!c || !s) continue;
        c.x = snap(s.x + dx);
        c.y = snap(s.y + dy);
      }
    }



    redraw();
    return;
  }


  ctx.font = labelSize + "px Arial";

  hoverSelect = null;
  hoverDelete = null;
  hoverLineLabel = null;

  lines.forEach((l, i) => {
    if (project(x, y, l).dist < 6) {
      hoverSelect = { type: "line", index: i };
      hoverDelete = { type: "line", index: i };
    }
    [[l.x1, l.y1], [l.x2, l.y2]].forEach((p, pi) => {
      if (Math.hypot(x - p[0], y - p[1]) < 6) {
        hoverSelect = { type: "endpoint", line: l, pt: pi === 0 ? "start" : "end" };
      }
    }, { passive: false });

    // Hover gutter length label (selector tool only)
    if (tool === "select" && showLabels) {
      const b = lineLabelBox(l);
      if (x >= b.x1 && x <= b.x2 && y >= b.y1 && y <= b.y2) {
        hoverLineLabel = l;
        hoverSelect = { type: "linelabel", line: l }; // keep for cursor/drag logic
      }
    }

  splashGuards.forEach((l, i) => {
    if (project(x, y, l).dist < 6) {
      hoverSelect = { type: "splashLine", index: i };
      hoverDelete = { type: "splashLine", index: i };
    }
    [[l.x1, l.y1], [l.x2, l.y2]].forEach((p, pi) => {
      if (Math.hypot(x - p[0], y - p[1]) < 6) {
        hoverSelect = { type: "splashEndpoint", line: l, pt: pi === 0 ? "start" : "end", isSplash: true };
      }
    });
  });

  });


  // Hover for splash guards (for Select endpoints + Erase highlight/delete)
  splashGuards.forEach((l, i) => {
    if (!l) return;
    const rs = getSplashRenderSegment(l);
    if (project(x, y, rs).dist < 6) {
      // Always allow erase hover/delete
      hoverDelete = { type: "splashLine", index: i };
      // Allow selector to pick the line
      if (tool === "select") hoverSelect = { type: "splashLine", index: i };
    }
    [[rs.x1, rs.y1], [rs.x2, rs.y2]].forEach((p, pi) => {
      if (Math.hypot(x - p[0], y - p[1]) < 6) {
        if (tool === "select") hoverSelect = { type: "splashEndpoint", line: l, pt: pi === 0 ? "start" : "end", isSplash: true };
      }
    });
  });

  downspouts.forEach((d, i) => {
    if (!d || !d.line) return;
    let l = d.line;
    let px = l.x1 + (l.x2 - l.x1) * d.offset;
    let py = l.y1 + (l.y2 - l.y1) * d.offset;
    if (Math.hypot(x - px, y - py) < DS_RADIUS) {
      hoverSelect = { type: "downspout", obj: d };
      hoverDelete = { type: "downspout", index: i };
    }

    // Hover DS label (selector tool only)
    if (tool === "select" && showLabels) {
      const b = dsLabelBox(d);
      if (x >= b.x1 && x <= b.x2 && y >= b.y1 && y <= b.y2) {
        hoverSelect = { type: "dslabel", obj: d };
      }
    }
  });

  doors.forEach((d, i) => {
    const b = doorBounds(d);
    if (x >= b.x1 && x <= b.x2 && y >= b.y1 && y <= b.y2) {
      hoverSelect = { type: "door", obj: d };
      if (tool === "eraser") {
      hoverDelete = { type: "door", index: i };
    }
    }
  });

  texts.forEach((t, i) => {
    const fs = (typeof t.size === "number" && isFinite(t.size)) ? t.size : labelSize;
    ctx.font = fs + "px Arial";
    const w = ctx.measureText(t.text || "").width;
    const x1 = t.x, y1 = t.y - fs, x2 = t.x + w, y2 = t.y;

    // Bottom-right handle hit (slightly larger hitbox)
    const hx = x2 + 3, hy = y2 + 3;
    const hit = 10;

    if (Math.abs(x - hx) <= hit && Math.abs(y - hy) <= hit) {
      hoverSelect = { type: "textResizeHandle", obj: t };
      hoverDelete = { type: "text", index: i };
      return;
    }

    if (x > x1 && x < x2 && y < y2 && y > y1) {
      hoverSelect = { type: "text", obj: t };
      hoverDelete = { type: "text", index: i };
    }
  });// Cursor feedback (selector tool)
  if (tool === "select") {
    if (hoverSelect && hoverSelect.type === "textResizeHandle") {
      canvas.style.cursor = "nwse-resize";
    } else if (hoverSelect && (hoverSelect.type === "linelabel" || hoverSelect.type === "text" || hoverSelect.type === "door" || hoverSelect.type === "downspout" || hoverSelect.type === "endpoint")) canvas.style.cursor = "move";
    else if (hoverSelect && hoverSelect.type === "line") canvas.style.cursor = "pointer";
    else canvas.style.cursor = "crosshair";
  } else {
    canvas.style.cursor = "crosshair";
  }


  if (panning) {
    panX = mx - panStart.x;
    panY = my - panStart.y;
    redraw(); return;
  }

  if (draggingLineLabel) {
    const dxm = x - labelDragStart.x;
    const dym = y - labelDragStart.y;

    draggingLineLabel.labelDx = textOffset.x + dxm;
    draggingLineLabel.labelDy = textOffset.y + dym;

    redraw(); return;
  }

if (draggingDsLabel) {
    const dxm = x - dsLabelDragStart.x;
    const dym = y - dsLabelDragStart.y;

    draggingDsLabel.labelDx = textOffset.x + dxm;
    draggingDsLabel.labelDy = textOffset.y + dym;

    redraw(); return;
  }

if (draggingPoint) {
    let ep = snapToEndpoint(x, y);
    if (ep) { x = ep.x; y = ep.y; }
    else { x = snap(x); y = snap(y); }
    draggingPoint.line[draggingPoint.pt === "start" ? "x1" : "x2"] = x;
    draggingPoint.line[draggingPoint.pt === "start" ? "y1" : "y2"] = y;
    if (!draggingPoint.isSplash) autoCorners();
    redraw(); return;
  }

  if (draggingDownspout) {
    if (!dsClickMoved && Math.hypot(x - dsClickStart.x, y - dsClickStart.y) > 2) dsClickMoved = true;
    // allow sliding across the connected gutter network (shared endpoints)
    const best = findBestDownspoutPlacement(x, y, draggingDownspout.line);
    if (best) {
      draggingDownspout.line = best.line;
      draggingDownspout.offset = best.t;
    } else {
      let l = draggingDownspout.line;
      draggingDownspout.offset = project(x, y, l).t;
    }
    redraw(); return;
  }

  if (draggingTextResize) {
    const t = draggingTextResize.obj;
    const curDist = Math.max(8, Math.hypot((x) - draggingTextResize.anchorX, (y) - draggingTextResize.anchorY));
    let newSize = draggingTextResize.startSize * (curDist / draggingTextResize.startDist);
    newSize = Math.max(8, Math.min(72, newSize));
    t.size = newSize;
    redraw(); return;
  }

  if (draggingText) {
    draggingText.x = snap(x - textOffset.x);
    draggingText.y = snap(y - textOffset.y);
    redraw(); return;
  }

  if (draggingDoor) {
    // track if this was a drag vs a click
    if (Math.hypot(x - doorClickStart.x, y - doorClickStart.y) > 6) doorClickMoved = true;
    draggingDoor.x = snap(x - doorOffset.x);
    draggingDoor.y = snap(y - doorOffset.y);
    redraw(); return;
  }

  if (drawingLine) {
    let ep = snapToEndpoint(x, y);
    if (ep) { drawingLine.x2 = ep.x; drawingLine.y2 = ep.y; }
    else { drawingLine.x2 = snap(x); drawingLine.y2 = snap(y); }
  }
  if (drawingSplash) {
    let ep = snapToEndpoint(x, y);
    if (ep) { drawingSplash.x2 = ep.x; drawingSplash.y2 = ep.y; }
    else { drawingSplash.x2 = snap(x); drawingSplash.y2 = snap(y); }
  }

  redraw();
});

canvas.addEventListener("pointerup", (e) => {
  if (e && e.pointerType === "touch") e.preventDefault();
  if (e && e.isPrimary === false) return;
  try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
  isPrimaryPointerDown = false;
  if (drawingLine) {
    const d = dist(drawingLine);
    // Prevent accidental 0ft gutters from click-without-drag
    if (d > 0) {
      saveState();
      lines.push(drawingLine);
      if (!drawingLine.kind || (drawingLine.kind !== "clean" && drawingLine.kind !== "cleanpro")) autoCorners();
    }
    drawingLine = null;
  }

  if (drawingSplash) {
    const d = dist(drawingSplash);
    if (d > 0) {
      saveState();
      splashGuards.push(drawingSplash);
    }
    drawingSplash = null;
  }
  draggingPoint = null;


  // Finish Move Section drag (tool button OR Shift+Select)
  if ((tool === "moveSection" || tool === "select") && moveSectionState.dragging) {
    moveSectionState.dragging = false;
    snapAll();
    cleanDownspouts();
    autoCorners();
    updateInventory();
        // Auto-unselect after move
    clearMoveSectionSelection();

    redraw();
    return;
  }

  // Selector click on a downspout (no drag) cycles quantity ‚ë†‚Üí‚ë°‚Üí‚ë¢‚Üí‚ë£‚Üí‚ë† and updates inventory
  if (draggingDownspout && tool === "select" && dsClickMoved === false) {
    // saveState already captured on mousedown when selecting the downspout
    draggingDownspout.qty = cycleDsQty(draggingDownspout.qty);
  }

  draggingDownspout = null;
  draggingTextResize = null;
  draggingText = null;
  draggingDoor = null;
  doorClickMoved = false;
  draggingLineLabel = null;
  labelDragAxis = null;
  draggingDsLabel = null;
  dsLabelDragAxis = null;
  if ((tool === "moveSection" || tool === "select") && moveSectionState.dragging) {
    moveSectionState.dragging = false;
    snapAll();
    cleanDownspouts();
    autoCorners();
    updateInventory();
    redraw();
    return;
  }

  panning = false;
  dsClickMoved = false;
  snapAll();
  redraw();
}, { passive: false });
canvas.addEventListener("pointercancel", (e) => {
  if (e && e.pointerType === "touch") e.preventDefault();
  if (e && e.isPrimary === false) return;
  try { canvas.releasePointerCapture(e.pointerId); } catch (err) {}
  isPrimaryPointerDown = false;
  if (drawingLine) {
    const d = dist(drawingLine);
    // Prevent accidental 0ft gutters from click-without-drag
    if (d > 0) {
      saveState();
      lines.push(drawingLine);
      autoCorners();
    }
    drawingLine = null;
  }

  if (drawingSplash) {
    const d = dist(drawingSplash);
    if (d > 0) {
      saveState();
      splashGuards.push(drawingSplash);
    }
    drawingSplash = null;
  }
  draggingPoint = null;


  // Finish Move Section drag (tool button OR Shift+Select)
  if ((tool === "moveSection" || tool === "select") && moveSectionState.dragging) {
    moveSectionState.dragging = false;
    snapAll();
    cleanDownspouts();
    autoCorners();
    updateInventory();
        // Auto-unselect after move
    clearMoveSectionSelection();

    redraw();
    return;
  }

  // Selector click on a downspout (no drag) cycles quantity ‚ë†‚Üí‚ë°‚Üí‚ë¢‚Üí‚ë£‚Üí‚ë† and updates inventory
  if (draggingDownspout && tool === "select" && dsClickMoved === false) {
    // saveState already captured on mousedown when selecting the downspout
    draggingDownspout.qty = cycleDsQty(draggingDownspout.qty);
  }

  draggingDownspout = null;
  draggingText = null;
  draggingDoor = null;
  doorClickMoved = false;
  draggingLineLabel = null;
  labelDragAxis = null;
  draggingDsLabel = null;
  dsLabelDragAxis = null;
  if ((tool === "moveSection" || tool === "select") && moveSectionState.dragging) {
    moveSectionState.dragging = false;
    snapAll();
    cleanDownspouts();
    autoCorners();
    updateInventory();
    redraw();
    return;
  }

  panning = false;
  dsClickMoved = false;
  snapAll();
  redraw();
}, { passive: false });

/* ---------- MATH ---------- */

function lineSig(l) {
  if (!l) return "";
  // Round to reduce floating errors
  const r = (v) => Math.round(v * 10) / 10;
  return [r(l.x1), r(l.y1), r(l.x2), r(l.y2), l.color || "", l.level || ""].join("|");
}

function cleanDownspouts() {
  if (!Array.isArray(downspouts) || !Array.isArray(lines)) { downspouts = []; return; }
  ensureLineIds();

  const sigMap = new Map();
  const idMap = new Map();
  lines.forEach(l => {
    idMap.set(l.id, l);
    sigMap.set(lineSig(l), l);
  });

  downspouts = downspouts.map(d => {
    if (!d) return null;

    // Normalize lineId
    if (typeof d.lineId !== "number" || !isFinite(d.lineId)) {
      d.lineId = (d.line && typeof d.line.id === "number") ? d.line.id : null;
    }

    // Attach by id (primary)
    if ((!d.line || !lines.includes(d.line)) && typeof d.lineId === "number") {
      const lById = idMap.get(d.lineId);
      if (lById) d.line = lById;
    }

    // Fallback: attach by signature if we still have a line object
    if (!d.line || !lines.includes(d.line)) {
      const l2 = sigMap.get(lineSig(d.line));
      if (l2) {
        d.line = l2;
        d.lineId = l2.id;
      }
    }

    // Still orphaned? drop it
    if (!d.line || !lines.includes(d.line)) return null;

    // Keep offset sane
    if (typeof d.offset !== "number" || !isFinite(d.offset)) d.offset = 0.5;
    d.offset = Math.max(0, Math.min(1, d.offset));

    // ensure label offsets exist
    if (typeof d.labelDx !== "number") d.labelDx = 0;
    if (typeof d.labelDy !== "number") d.labelDy = 0;

    return d;
  }).filter(Boolean);
}


function project(px, py, l) {
  let A = px - l.x1, B = py - l.y1, C = l.x2 - l.x1, D = l.y2 - l.y1;
  let dot = A * C + B * D, len = C * C + D * D;
  let t = Math.max(0, Math.min(1, dot / len));
  return { t, dist: Math.hypot(px - (l.x1 + t * C), py - (l.y1 + t * D)) };
}

/* ---------- DS CONNECTED SLIDE ---------- */
function ptKey(x, y) {
  const q = 1000; // 0.001 precision
  return (Math.round(x * q) / q) + "," + (Math.round(y * q) / q);
}

// Corner IC/OC toggles (display-only)
let cornerIOToggles = new Map(); // key -> "IC" | "OC"

function getCornerIO(x, y) {
  const key = ptKey(x, y);
  return cornerIOToggles.get(key) || "IC";
}
function toggleCornerIOAt(x, y) {
  const key = ptKey(x, y);
  const cur = cornerIOToggles.get(key) || "IC";
  const next = (cur === "IC") ? "OC" : "IC";
  cornerIOToggles.set(key, next);
  return next;
}

function buildEndpointMap() {
  const map = new Map();
  for (const l of lines) {
    const k1 = ptKey(l.x1, l.y1);
    const k2 = ptKey(l.x2, l.y2);

    if (!map.has(k1)) map.set(k1, []);
    if (!map.has(k2)) map.set(k2, []);

    map.get(k1).push(l);
    map.get(k2).push(l);
  }
  return map;
}
function getConnectedLines(startLine) {
  if (!startLine) return [];
  const endpointMap = buildEndpointMap();
  const visited = new Set();
  const queue = [startLine];
  visited.add(startLine);

  while (queue.length) {
    const cur = queue.shift();
    const keys = [ptKey(cur.x1, cur.y1), ptKey(cur.x2, cur.y2)];

    for (const k of keys) {
      const arr = endpointMap.get(k) || [];
      for (const other of arr) {
        if (!visited.has(other)) {
          visited.add(other);
          queue.push(other);
        }
      }
    }
  }
  return Array.from(visited);
}
function findBestDownspoutPlacement(px, py, currentLine) {
  const component = getConnectedLines(currentLine);
  if (!component.length) return null;

  let best = null;
  for (const l of component) {
    const p = project(px, py, l);
    if (!best || p.dist < best.dist) {
      best = { line: l, t: p.t, dist: p.dist };
    }
  }

  if (best && best.dist < 30) return best;

  return { line: currentLine, t: project(px, py, currentLine).t, dist: project(px, py, currentLine).dist };
}

/* ---------- ALIGNMENT GUIDELINES (SAFE DRAW-ONLY) ---------- */
function getAllGutterEndpoints() {
  let pts = [];
  for (let l of lines) {
    pts.push({ x: l.x1, y: l.y1, line: l, pt: "start" });
    pts.push({ x: l.x2, y: l.y2, line: l, pt: "end" });
  }
  return pts;
}
function drawAlignmentGuidesFor(movingX, movingY, ignoreLine) {
  const EPS = 0.5;
  const endpoints = getAllGutterEndpoints();

  ctx.save();
  ctx.strokeStyle = "rgba(0,0,0,0.35)";
  ctx.lineWidth = 2;
  ctx.setLineDash([8, 8]);

  let bestX = null, bestXDist = Infinity;
  let bestY = null, bestYDist = Infinity;

  for (let p of endpoints) {
    if (ignoreLine && p.line === ignoreLine) continue;
    if (p.x === movingX && p.y === movingY) continue;

    if (Math.abs(p.x - movingX) <= EPS) {
      let d = Math.abs(p.y - movingY);
      if (d < bestXDist) { bestXDist = d; bestX = p; }
    }
    if (Math.abs(p.y - movingY) <= EPS) {
      let d = Math.abs(p.x - movingX);
      if (d < bestYDist) { bestYDist = d; bestY = p; }
    }
  }

  if (bestX) {
    ctx.beginPath();
    ctx.moveTo(movingX, movingY);
    ctx.lineTo(bestX.x, bestX.y);
    ctx.stroke();
  }
  if (bestY) {
    ctx.beginPath();
    ctx.moveTo(movingX, movingY);
    ctx.lineTo(bestY.x, bestY.y);
    ctx.stroke();
  }

  ctx.restore();
}

/* ---------- DOOR (CAD STYLE) ---------- */
function doorBounds(d) {
  const w = (d.wFeet || 3) * gridSize;
  const pad = 8;
  return { x1: d.x - pad, y1: d.y - pad, x2: d.x + w + pad, y2: d.y + w + pad };
}

function flipDoorAcrossNearestLine(d) {
  if (!d) return;
  // Find nearest gutter line
  let best = null, bestLine = null;
  for (const l of lines) {
    if (!l) continue;
    const p = project(d.x, d.y, l);
    if (best === null || p.dist < best) { best = p.dist; bestLine = l; }
  }
  if (!bestLine) {
    d.flip = !d.flip;
    return;
  }
  const p = project(d.x, d.y, bestLine);
  // Mirror point across the line
  let vx = d.x - p.x;
  let vy = d.y - p.y;

  // If essentially on the line, push to the other side using the line normal
  if (Math.hypot(vx, vy) < 0.001) {
    const dx = bestLine.x2 - bestLine.x1;
    const dy = bestLine.y2 - bestLine.y1;
    const len = Math.hypot(dx, dy) || 1;
    const nx = -dy / len;
    const ny = dx / len;
    const w = (d.wFeet || 3) * gridSize;
    const push = Math.max(gridSize * 0.5, w * 0.35);
    vx = nx * push;
    vy = ny * push;
  }

  d.x = snap(d.x - 2 * vx);
  d.y = snap(d.y - 2 * vy);
  d.flip = !d.flip;
}

function drawDoor(d) {
  const w = (d.wFeet || 3) * gridSize;
  const x = d.x, y = d.y;
  const flip = !!d.flip; // false: arc down/right, true: arc up/right

  ctx.save();
  ctx.strokeStyle = "black";
  ctx.lineWidth = 2;

  // baseline (to the right)
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x + w, y);
  ctx.stroke();

  // hinge line (up or down)
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.lineTo(x, y + (flip ? -w : w));
  ctx.stroke();

  // swing arc
  ctx.beginPath();
  const start = flip ? -Math.PI / 2 : 0;
  const end = flip ? 0 : Math.PI / 2;
  ctx.arc(x, y, w, start, end);
  ctx.stroke();

  // Label
  ctx.font = Math.max(12, Math.round(labelSize * 0.9)) + "px Arial";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillStyle = "black";
  const ly = y + (flip ? -w * 0.45 : w * 0.45);
  ctx.fillText("DOOR", x + w * 0.45, ly);

  // hinge handle
  ctx.fillStyle = "black";
  ctx.fillRect(x - 2, y - 2, 4, 4);

  ctx.restore();
}


/* ---------- DRAW HELPERS ---------- */
function drawParallelLines(x1, y1, x2, y2, offsetPx, lineWidthPx) {
  const dx = x2 - x1;
  const dy = y2 - y1;
  const len = Math.hypot(dx, dy) || 1;

  // Unit normal (perpendicular)
  const nx = -dy / len;
  const ny =  dx / len;

  const ox = nx * offsetPx;
  const oy = ny * offsetPx;

  ctx.setLineDash([]);
  ctx.lineWidth = lineWidthPx;

  ctx.beginPath();
  ctx.moveTo(x1 + ox, y1 + oy);
  ctx.lineTo(x2 + ox, y2 + oy);
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(x1 - ox, y1 - oy);
  ctx.lineTo(x2 - ox, y2 - oy);
  ctx.stroke();
}





function drawTRexOverlayForLine(l) {
  if (!l || typeof l.id !== "number") return;
  if (!coverTRexLineIds || !coverTRexLineIds.has(l.id)) return;

  const dx = l.x2 - l.x1;
  const dy = l.y2 - l.y1;
  const len = Math.hypot(dx, dy) || 1;

  // unit direction along gutter
  const ux = dx / len;
  const uy = dy / len;

  // normal for parallel offset (SIDE B)
  let nx = -dy / len;
let ny = dx / len;

  // Force covers to N/E side: choose normal pointing most toward NE vector [1,-1]
  const dot1 = nx - ny;
  const dot2 = -nx + ny;
  if (dot2 > dot1) { nx = -nx; ny = -ny; }


  const offset = 6; // T-Rex on N/E side
  const px1 = l.x1 + nx * offset;
  const py1 = l.y1 + ny * offset;

  ctx.save();
  ctx.fillStyle = "black";

  const _opts = (typeof opts === "object" && opts) ? opts : {};
  const dotRadius = (_opts && _opts.highlight) ? 2.4 : 1.6;
  const gap = 10;

  let dist = 0;
  while (dist < len) {
    const xDot = px1 + ux * dist;
    const yDot = py1 + uy * dist;
    ctx.beginPath();
    ctx.arc(xDot, yDot, dotRadius, 0, Math.PI * 2);
    ctx.fill();
    dist += gap;
  }

  ctx.restore();
}











function drawDoubleProOverlayForLine(l) {
  if (!l || typeof l.id !== "number") return;
  if (!coverDoubleProLineIds || !coverDoubleProLineIds.has(l.id)) return;

  const dx = l.x2 - l.x1;
  const dy = l.y2 - l.y1;
  const len = Math.hypot(dx, dy) || 1;

  // unit direction along gutter
  const ux = dx / len;
  const uy = dy / len;

  // normal for parallel offset (SIDE B)
  let nx = -dy / len;
let ny = dx / len;

  // Force covers to N/E side: choose normal pointing most toward NE vector [1,-1]
  const dot1 = nx - ny;
  const dot2 = -nx + ny;
  if (dot2 > dot1) { nx = -nx; ny = -ny; }


  const offset = 6; // Double PRO also on Side B
  const px1 = l.x1 + nx * offset;
  const py1 = l.y1 + ny * offset;

  ctx.save();
  ctx.strokeStyle = "black";
  ctx.fillStyle = "black";
  ctx.lineWidth = 2;

  const dotRadius = 1.6;
  const dashLen = 16;
  const gap = 10;

  let dist = 0;
  while (dist < len) {
    // DOT
    const xDot = px1 + ux * dist;
    const yDot = py1 + uy * dist;
    ctx.beginPath();
    ctx.arc(xDot, yDot, dotRadius, 0, Math.PI * 2);
    ctx.fill();
    dist += gap;

    // DASH
    const x1 = px1 + ux * dist;
    const y1 = py1 + uy * dist;
    const x2 = px1 + ux * Math.min(dist + dashLen, len);
    const y2 = py1 + uy * Math.min(dist + dashLen, len);

    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(x2, y2);
    ctx.stroke();

    dist += dashLen + gap;
  }

  ctx.restore();
}








function drawGutterCleanDots(l, opts = {}) {
  if (!l) return;
  const dx = l.x2 - l.x1;
  const dy = l.y2 - l.y1;
  const len = Math.hypot(dx, dy) || 1;
  const ux = dx / len;
  const uy = dy / len;

  // Match T-Rex-like dotted look
  const dotRadius = 1.6;
  const gap = 10;

  ctx.save();
  const highlight = !!(opts && opts.highlight);
  ctx.fillStyle = highlight ? "orange" : "black";
  let distAlong = 0;
  while (distAlong < len) {
    const xDot = l.x1 + ux * distAlong;
    const yDot = l.y1 + uy * distAlong;
    ctx.beginPath();
    ctx.arc(xDot, yDot, dotRadius, 0, Math.PI * 2);
    ctx.fill();
    distAlong += gap;
  }
  ctx.restore();
}


function drawDotDashPattern(l, opts = {}) {
  if (!l) return;
  const dx = l.x2 - l.x1;
  const dy = l.y2 - l.y1;
  const len = Math.hypot(dx, dy) || 1;
  const ux = dx / len;
  const uy = dy / len;

    const dotR = (opts && opts.highlight) ? 2.4 : 1.6;
    const dashLen = 16;
    const gap = 10;

  ctx.save();
  const highlight = !!(opts && opts.highlight);
  ctx.strokeStyle = highlight ? "orange" : "black";
  ctx.fillStyle = highlight ? "orange" : "black";
    ctx.lineWidth = highlight ? 4 : 2;
  ctx.lineCap = "round";

    let dist = 0;
  while (dist < len) {
    // DOT
    const xDot = l.x1 + ux * dist;
    const yDot = l.y1 + uy * dist;
    ctx.beginPath();
    ctx.arc(xDot, yDot, dotR, 0, Math.PI * 2);
    ctx.fill();
    dist += gap;

    // DASH
    const x1 = l.x1 + ux * dist;
    const y1 = l.y1 + uy * dist;
    const end = Math.min(len, dist + dashLen);
    ctx.beginPath();
    ctx.moveTo(x1, y1);
    ctx.lineTo(l.x1 + ux * end, l.y1 + uy * end);
    ctx.stroke();

    dist = end + gap;
  }

  ctx.restore();
}

function drawGutterStroke(lineObj, opts = {}) {
  if (!lineObj || typeof lineObj.x1 !== 'number' || typeof lineObj.y1 !== 'number' || typeof lineObj.x2 !== 'number' || typeof lineObj.y2 !== 'number') return;

  // Gutter Clean PRO¬Æ: dot-dash-dot pattern
  if (lineObj && lineObj.kind === "cleanpro") { drawDotDashPattern(lineObj, opts); return; }

  // Gutter Clean¬Æ: render as dotted (same visual style as T-Rex dots)
  if (lineObj && lineObj.kind === "clean") { drawGutterCleanDots(lineObj, opts); return; }

  // Upper and Lower gutters draw the same (single line).
  // Differentiation is shown only in the length label suffix (subscript-style L/U).
  const highlight = !!opts.highlight;

  ctx.setLineDash([]);
  ctx.lineWidth = highlight ? 5 : 3;
  ctx.beginPath();
  ctx.moveTo(lineObj.x1, lineObj.y1);
  ctx.lineTo(lineObj.x2, lineObj.y2);
  if (opts && opts.previewDashed) ctx.setLineDash([8, 8]);
    ctx.stroke();
    if (opts && opts.previewDashed) ctx.setLineDash([]);
}

// PVC applied markers (Option 1): small perpendicular ticks along gutter line

function drawPVCTicks(lineObj, kind) {
  if (!lineObj) return;

  const x1 = lineObj.x1, y1 = lineObj.y1, x2 = lineObj.x2, y2 = lineObj.y2;
  const dx = x2 - x1, dy = y2 - y1;
  const len = Math.sqrt(dx*dx + dy*dy);
  if (!len || !isFinite(len)) return;

  const ux = dx / len, uy = dy / len;
  const px = -uy, py = ux;

  ctx.save();
  ctx.strokeStyle = "rgba(220,0,0,0.9)";
  ctx.setLineDash([]);

  
  // --- PVC WEDGES: DOUBLE PERPENDICULAR TICKS (OFFSET TO W/S SIDE) ---
  if (kind === "wedges") {
    const spacingPx = 4 * gridSize;
    const tickLenPx = 0.18 * gridSize;
    const doubleSepPx = 0.25 * gridSize;
    ctx.lineWidth = 2;

    // Determine covers side as NE, then flip to W/S for wedges
    const dot1 = px - py;
    const dot2 = -px + py;
    let nx = px, ny = py;
    if (dot2 > dot1) { nx = -px; ny = -py; }

    const ox = -nx;
    const oy = -ny;

    const sideOffsetPx = tickLenPx * 0.5; // no gap: tick inner end sits on gutter line

    const insetPx = 0.6 * gridSize;
    let t = insetPx + spacingPx * 0.5;
    while (t < len - insetPx) {
      const cx = x1 + ux * t + ox * sideOffsetPx;
      const cy = y1 + uy * t + oy * sideOffsetPx;

      function tick(offsetAlong) {
        const tx = cx + ux * offsetAlong;
        const ty = cy + uy * offsetAlong;
        ctx.beginPath();
        ctx.moveTo(tx - ox * tickLenPx * 0.5, ty - oy * tickLenPx * 0.5);
        ctx.lineTo(tx + ox * tickLenPx * 0.5, ty + oy * tickLenPx * 0.5);
        ctx.stroke();
      }

      tick(-doubleSepPx * 0.5);
      tick(doubleSepPx * 0.5);
      t += spacingPx;
    }
  }


  
  
  
  // --- ADD-A-BOARD: THIN PARALLEL LINE (FORCED SIDE)
  // Rule: Covers are always on the N/E side; Add-A-Board is always on the W/S side.
  // Implementation: choose the gutter normal that points MOST toward NE (vector [1,-1]) for the "covers side".
  // Then draw Add-A-Board on the opposite normal (SW).
  if (kind === "addaboard") {
    ctx.lineWidth = 1.5;

    const base = 0.12 * gridSize;

    // Two possible unit normals: (px,py) and (-px,-py)
    const dot1 = px - py;        // dot((px,py), (1,-1))
    const dot2 = -px + py;       // dot((-px,-py),(1,-1)) = -px + py

    let nx = px, ny = py; // covers side normal
    if (dot2 > dot1) { nx = -px; ny = -py; }

    // Add-A-Board on opposite side (SW)
    const ox = -nx * base;
    const oy = -ny * base;

    ctx.beginPath();
    ctx.moveTo(x1 + ox, y1 + oy);
    ctx.lineTo(x2 + ox, y2 + oy);
    ctx.stroke();
  }




  ctx.restore();
}


function drawPVCTicksForLine(lineObj) {
  if (!lineObj || typeof lineObj.id !== "number") return;
  if (pvcWedgesLineIds && pvcWedgesLineIds.has(lineObj.id)) drawPVCTicks(lineObj, "wedges");
  else if (pvcAddBoardLineIds && pvcAddBoardLineIds.has(lineObj.id)) drawPVCTicks(lineObj, "addaboard");
}



/* ---------- DRAW ---------- */
function autoCorners() {
  corners = [];
  const seen = new Set();

  for (let i = 0; i < lines.length; i++) {
    for (let j = i + 1; j < lines.length; j++) {
      let a = lines[i], b = lines[j];
      const aPts = [[a.x1, a.y1], [a.x2, a.y2]];
      const bPts = [[b.x1, b.y1], [b.x2, b.y2]];

      for (const p of aPts) {
        for (const q of bPts) {
          if (Math.hypot(p[0] - q[0], p[1] - q[1]) < 1) {
            const key = ptKey(p[0], p[1]);
            if (!seen.has(key)) {
              seen.add(key);
              corners.push({ x: p[0], y: p[1] });
            }
          }
        }
      }
    }
  }
}

function drawGrid() {
  ctx.strokeStyle = "rgba(0,0,0,0.1)";
  let startX = Math.floor(-panX / gridSize) * gridSize + panX;
  let startY = Math.floor(-panY / gridSize) * gridSize + panY;
  for (let x = startX; x < canvas.width; x += gridSize) {
    ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
  }
  for (let y = startY; y < canvas.height; y += gridSize) {
    ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke();
  }
}

// Splash Guard: render-only offset when both endpoints are near the SAME gutter segment.
// Corner splash guards stay as drawn.
const SPLASH_OFFSET_PX = 6;
const SPLASH_ATTACH_DIST = 10;

function nearestGutterHit(x, y) {
  let best = null;
  let bestDist = Infinity;
  for (const gl of lines) {
    if (!gl) continue;
    const p = project(x, y, gl);
    if (p.dist < bestDist) {
      bestDist = p.dist;
      best = { line: gl, dist: p.dist };
    }
  }
  return best;
}

function getSplashRenderSegment(sg) {
  const seg = { x1: sg.x1, y1: sg.y1, x2: sg.x2, y2: sg.y2 };
  if (!lines || !lines.length) return seg;

  const h1 = nearestGutterHit(sg.x1, sg.y1);
  const h2 = nearestGutterHit(sg.x2, sg.y2);
  if (!h1 || !h2) return seg;
  if (h1.dist > SPLASH_ATTACH_DIST || h2.dist > SPLASH_ATTACH_DIST) return seg;

  const l1 = h1.line, l2 = h2.line;
  if (!l1 || !l2) return seg;
  if (typeof l1.id !== "number" || typeof l2.id !== "number") return seg;
  if (l1.id !== l2.id) return seg;

  const dx = l1.x2 - l1.x1;
  const dy = l1.y2 - l1.y1;
  const len = Math.hypot(dx, dy) || 1;
  const nx = -dy / len;
  const ny = dx / len;

  const mx = (sg.x1 + sg.x2) / 2;
  const my = (sg.y1 + sg.y2) / 2;
  const vx = mx - l1.x1;
  const vy = my - l1.y1;
  const cross = dx * vy - dy * vx;
  const sign = (cross >= 0) ? 1 : -1;

  seg.x1 = sg.x1 + nx * SPLASH_OFFSET_PX * sign;
  seg.y1 = sg.y1 + ny * SPLASH_OFFSET_PX * sign;
  seg.x2 = sg.x2 + nx * SPLASH_OFFSET_PX * sign;
  seg.y2 = sg.y2 + ny * SPLASH_OFFSET_PX * sign;
  return seg;
}


function dist(l) {
  let dx = (l.x2 - l.x1) / gridSize, dy = (l.y2 - l.y1) / gridSize;
  return Math.round(Math.sqrt(dx * dx + dy * dy));
}

function gutterLabelParts(l) {
  const base = dist(l) + "'";
  const lvl = (l && l.level) ? l.level : "lower";
  const sub = (lvl === "upper") ? "U" : "L";
  return { base, sub };
}

// Measure width of base + small gap + subscript (smaller font)
function measureGutterLabelWidth(l) {
  const parts = gutterLabelParts(l);
  const baseW = ctx.measureText(parts.base).width;

  ctx.save();
  ctx.font = Math.max(10, Math.round(labelSize * 0.72)) + "px Arial";
  const subW = ctx.measureText(parts.sub).width;
  ctx.restore();

  return baseW + 2 + subW;
}

// Draw base text + "subscript-style" L/U (smaller and slightly lower)
function drawGutterLengthLabel(l, x, y) {
  const parts = gutterLabelParts(l);

  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  ctx.fillText(parts.base, x, y);

  const baseW = ctx.measureText(parts.base).width;

  ctx.save();
  const subSize = Math.max(10, Math.round(labelSize * 0.72));
  ctx.font = subSize + "px Arial";
  const ySub = y + Math.max(2, Math.round(labelSize * 0.22));
  ctx.fillText(parts.sub, x + baseW + 2, ySub);
  ctx.restore();
}


function labelOffset(l) {
  let mx = (l.x1 + l.x2) / 2, my = (l.y1 + l.y2) / 2;
  let dx = l.x2 - l.x1, dy = l.y2 - l.y1;
  let len = Math.hypot(dx, dy) || 1;

  // Default: offset perpendicular to the gutter
  const baseX = mx + (-dy / len) * labelSize * 1.2;
  const baseY = my + (dx / len) * labelSize * 1.2;

  // User-adjustable nudge (in world/pixel units)
  const ox = (typeof l.labelDx === "number") ? l.labelDx : 0;
  const oy = (typeof l.labelDy === "number") ? l.labelDy : 0;

  return { x: baseX + ox, y: baseY + oy };
}


function lineLabelBox(l) {
  // Must have ctx.font set before calling
  const pos = labelOffset(l);
  const w = measureGutterLabelWidth(l);
  const h = labelSize;
  const pad = 4;

  return { x1: pos.x - pad, y1: pos.y - h - pad, x2: pos.x + w + pad, y2: pos.y + pad, pos };
}


function downspoutLabelAnchor(d) {
  const l = d.line;
  const px = l.x1 + (l.x2 - l.x1) * d.offset;
  const py = l.y1 + (l.y2 - l.y1) * d.offset;

  let dx = l.x2 - l.x1;
  let dy = l.y2 - l.y1;
  let offset = DS_RADIUS + labelSize;

  // Default cardinal direction based on gutter orientation
  let x = px, y = py;
  if (Math.abs(dx) > Math.abs(dy)) {
    // mostly horizontal gutter -> label goes north/south
    const s = (dy > 0 ? 1 : -1) * (d.labelFlip ? -1 : 1);
    y = py + s * offset;
  } else {
    // mostly vertical gutter -> label goes east/west
    const s = (dx > 0 ? 1 : -1) * (d.labelFlip ? -1 : 1);
    x = px + s * offset;
  }
  return { x, y, px, py };
}

function dsLabelBox(d) {
  // Must have ctx.font set before calling
  const a = downspoutLabelAnchor(d);

  const ox = (typeof d.labelDx === "number") ? d.labelDx : 0;
  const oy = (typeof d.labelDy === "number") ? d.labelDy : 0;

  const x = a.x + ox;
  const y = a.y + oy;

  const lvl = (d.line && d.line.level === "upper") ? "upper" : "lower";
  const text = (lvl === "upper") ? "DS‚ë°" : "DS‚ë†";
  const w = ctx.measureText(text).width;
  const h = labelSize;
  const pad = 6;

  // DS label is drawn with textAlign="center"
  return { x1: x - (w / 2) - pad, y1: y - h - pad, x2: x + (w / 2) + pad, y2: y + pad, x, y, text };
}
function downspoutLabelPosition(x, y, l) {
  let dx = l.x2 - l.x1;
  let dy = l.y2 - l.y1;
  let offset = DS_RADIUS + labelSize;

  if (Math.abs(dx) > Math.abs(dy)) {
    return { x: x, y: y + (dy > 0 ? offset : -offset) };
  } else {
    return { x: x + (dx > 0 ? offset : -offset), y: y };
  }
}

function redraw() {
  cleanDownspouts();
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  drawGrid();

  ctx.save();
  ctx.translate(panX, panY);
  ctx.font = labelSize + "px Arial";

  // Guidelines only while dragging endpoints or drawing a new line
  if (drawingLine) {
    drawAlignmentGuidesFor(drawingLine.x2, drawingLine.y2, null);
  }
  if (draggingPoint && draggingPoint.type === "endpoint") {
    const l = draggingPoint.line;
    const mx = (draggingPoint.pt === "start") ? l.x1 : l.x2;
    const my = (draggingPoint.pt === "start") ? l.y1 : l.y2;
    drawAlignmentGuidesFor(mx, my, l);
  }
doors.forEach((d, di) => {
    drawDoor(d);
    if ((tool === "moveSection" || tool === "select") && moveSectionState.doorIdxs && moveSectionState.doorIdxs.has(di)) {
      const w = (d.wFeet || 3) * gridSize;
      ctx.save();
      ctx.strokeStyle = "rgba(255,165,0,0.9)";
      ctx.lineWidth = 3;
      ctx.strokeRect(d.x - 10, d.y - 10, w + 20, w + 20);
      ctx.restore();
    }
  });

  // Gutters
  lines.forEach(l => {
    ctx.strokeStyle = l.color;
    drawGutterStroke(l);
    drawTRexOverlayForLine(l);
    drawDoubleProOverlayForLine(l);
    drawPVCTicksForLine(l);
    // Covers hover highlight (T-Rex / Double PRO) ‚Äî highlight EXACTLY on gutter strokes
    if (tool === "covers" && (coverType === "T-Rex" || coverType === "Double PRO") && hoverCoverLineIds && typeof l.id === "number" && hoverCoverLineIds.has(l.id)) {
      ctx.save();
      // Use the same gutter drawing function so highlight matches upper/lower styling (double lines, etc.)
      ctx.strokeStyle = "rgba(255,165,0,0.75)";
      ctx.lineWidth = 3;
      ctx.setLineDash([]);
      if (typeof drawGutterStroke === "function") {
        drawGutterStroke(l, { highlight: true });
      } else {
        ctx.beginPath();
        ctx.moveTo(l.x1, l.y1);
        ctx.lineTo(l.x2, l.y2);
        ctx.stroke();
      }
      ctx.restore();
    }

    // PVC hover highlight (Wedges / Add-A-Board) ‚Äî highlight EXACTLY on gutter strokes
    if (tool === "pvc" && (pvcType === "wedges" || pvcType === "addaboard") && hoverPVCLineIds && typeof l.id === "number" && hoverPVCLineIds.has(l.id)) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,165,0,0.75)";
      ctx.setLineDash([]);
      if (typeof drawGutterStroke === "function") {
        drawGutterStroke(l, { highlight: true });
      } else {
        ctx.beginPath();
        ctx.moveTo(l.x1, l.y1);
        ctx.lineTo(l.x2, l.y2);
        ctx.stroke();
      }
      ctx.restore();
    }

    if ((tool === "moveSection" || tool === "select") && moveSectionState.lineIds && moveSectionState.lineIds.has(l.id)) {
      ctx.save();
      ctx.strokeStyle = "rgba(255,165,0,0.65)";
      ctx.lineWidth = 6;
      ctx.setLineDash([]);
      ctx.beginPath();
      const rs = getSplashRenderSegment(l);
      ctx.moveTo(rs.x1, rs.y1);
      ctx.lineTo(rs.x2, rs.y2);
      ctx.stroke();
      ctx.restore();
    }
    ctx.setLineDash([]); // ensure labels/boxes are solid

    let pos = labelOffset(l);
    ctx.fillStyle = "black";
    if (showLabels) drawGutterLengthLabel(l, pos.x, pos.y);
    ctx.fillRect(l.x1 - 3, l.y1 - 3, 6, 6);
    ctx.fillRect(l.x2 - 3, l.y2 - 3, 6, 6);
  });

  // Splash Guards
  splashGuards.forEach(l => {
    ctx.save();
    ctx.strokeStyle = "#007bff";
    ctx.fillStyle = "#007bff";
    const rs = getSplashRenderSegment(l);
    ctx.strokeStyle = "#007bff";
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    ctx.beginPath();
    ctx.moveTo(rs.x1, rs.y1);
    ctx.lineTo(rs.x2, rs.y2);
    ctx.stroke();
    // endpoints
    ctx.fillStyle = "#007bff";
    ctx.fillRect(rs.x1 - 2, rs.y1 - 2, 4, 4);
    ctx.fillRect(rs.x2 - 2, rs.y2 - 2, 4, 4);
    ctx.restore();
  });


  // Erase hover highlight for splash guards
  if (tool === "eraser" && hoverDelete && hoverDelete.type === "splashLine") {
    const l = splashGuards[hoverDelete.index];
    if (l) {
      ctx.save();
      ctx.strokeStyle = "red";
      ctx.lineWidth = 4;
      ctx.setLineDash([]);
      ctx.beginPath();
      const rs = getSplashRenderSegment(l);
      ctx.moveTo(rs.x1, rs.y1);
      ctx.lineTo(rs.x2, rs.y2);
      ctx.stroke();
      ctx.restore();
    }
  }


  // Live splash guard preview
  if (drawingSplash) {
    ctx.save();
    ctx.strokeStyle = "#007bff";
    ctx.strokeStyle = "#007bff";
    ctx.lineWidth = 2;
    ctx.setLineDash([8, 6]);
    ctx.beginPath();
    ctx.moveTo(drawingSplash.x1, drawingSplash.y1);
    ctx.lineTo(drawingSplash.x2, drawingSplash.y2);
    ctx.stroke();
    ctx.restore();
  }

  // Live gutter preview
  if (drawingLine) {
    ctx.strokeStyle = drawingLine.color;
    drawGutterStroke(drawingLine, { previewDashed: true });
    ctx.setLineDash([]);

    let pos = labelOffset(drawingLine);
    ctx.fillStyle = "black";
    if (showLabels) drawGutterLengthLabel(drawingLine, pos.x, pos.y);
    }

  corners.forEach(c => {
    ctx.strokeStyle = "green";
    ctx.lineWidth = 2;
    ctx.strokeRect(c.x - 9, c.y - 9, 18, 18);
  
    // IC / OC label (respects Labels On/Off)
    if (showLabels) {
      const io = getCornerIO(c.x, c.y);
      ctx.font = "13px Arial";
      ctx.fillStyle = "green";
      ctx.textAlign = "left";
      ctx.textBaseline = "bottom";
      ctx.fillText(io, c.x + 9 + 4, c.y - 9 - 4);
    }
});

  // Downspouts
  downspouts.forEach(d => {
    if (!d || !d.line) return;
    let l = d.line;
    let x = l.x1 + (l.x2 - l.x1) * d.offset;
    let y = l.y1 + (l.y2 - l.y1) * d.offset;

    ctx.fillStyle = "red";
    const _dsType = (window.__UPG_SWAP_3X4 ? "3x4" : (d.type || "2x3"));
    if (_dsType === "3x4") {
      const s = DS_RADIUS * 2;
      ctx.fillRect(x - DS_RADIUS, y - DS_RADIUS, s, s);
    } else {
      ctx.beginPath(); ctx.arc(x, y, DS_RADIUS, 0, Math.PI * 2); ctx.fill();
    }

    // Move Section highlight downspout
    if ((tool === "moveSection" || tool === "select") && moveSectionState.lineIds) {
      const did = (typeof d.lineId === "number") ? d.lineId : (d.line && typeof d.line.id === "number" ? d.line.id : null);
      if (did !== null && moveSectionState.lineIds.has(did)) {
        ctx.save();
        ctx.strokeStyle = "rgba(255,165,0,0.65)";
      ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.arc(x, y, DS_RADIUS + 5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    const a = downspoutLabelAnchor(d);
    let lp = { x: a.x, y: a.y };
    ctx.fillStyle = "black";
    ctx.textAlign = "center";
    const ox = (typeof d.labelDx === "number") ? d.labelDx : 0;
    const oy = (typeof d.labelDy === "number") ? d.labelDy : 0;
    const sym = dsQtyToSymbol(d.qty);
    if (showLabels) drawDsLabel(lp.x + ox, lp.y + oy, sym);
    ctx.textAlign = "left";
  });

  // Texts
  texts.forEach(t => {
    ctx.fillStyle = t.color;
    const fs = (typeof t.size === "number" && isFinite(t.size)) ? t.size : labelSize;
    ctx.font = fs + "px Arial";
    ctx.fillText(t.text, t.x, t.y);
  });

  
  // Selected Text resize box (Step 1)
  if (selectedTextObj) {
    const t = selectedTextObj;
    const fs = (typeof t.size === "number" && isFinite(t.size)) ? t.size : labelSize;
    ctx.save();
    ctx.font = fs + "px Arial";
    const w = ctx.measureText(t.text || "").width;
    const x1 = t.x, y1 = t.y - fs, x2 = t.x + w, y2 = t.y;
    ctx.setLineDash([6, 4]);
    ctx.strokeStyle = "rgba(0,0,0,0.55)";
    ctx.lineWidth = 1.5;
    ctx.strokeRect(x1 - 3, y1 - 3, (x2 - x1) + 6, (y2 - y1) + 6);

    // Bottom-right resize handle
    const hs = 8;
    const hx = x2 + 3, hy = y2 + 3;
    ctx.setLineDash([]);
    ctx.fillStyle = "white";
    ctx.strokeStyle = "rgba(0,0,0,0.6)";
    ctx.lineWidth = 1;
    ctx.fillRect(hx - hs/2, hy - hs/2, hs, hs);
    ctx.strokeRect(hx - hs/2, hy - hs/2, hs, hs);
    ctx.restore();
  }

// Hover highlight
  if (hoverSelect) {
    ctx.strokeStyle = "orange";
    ctx.lineWidth = 2;

    if (hoverSelect.type === "line") {
      let l = lines[hoverSelect.index];
      drawGutterStroke(l, { highlight: true });
      ctx.setLineDash([]);
    }
    if (hoverSelect.type === "endpoint") {
      let l = hoverSelect.line;
      let x = hoverSelect.pt === "start" ? l.x1 : l.x2;
      let y = hoverSelect.pt === "start" ? l.y1 : l.y2;
      ctx.strokeRect(x - 6, y - 6, 12, 12);
    }
    if (hoverSelect.type === "downspout") {
      let l = hoverSelect.obj.line;
      let x = l.x1 + (l.x2 - l.x1) * hoverSelect.obj.offset;
      let y = l.y1 + (l.y2 - l.y1) * hoverSelect.obj.offset;
      ctx.beginPath(); ctx.arc(x, y, DS_RADIUS + 3, 0, Math.PI * 2); ctx.stroke();
    }
    if (hoverSelect.type === "text") {
      let t = hoverSelect.obj;
      let w = ctx.measureText(t.text).width;
      ctx.strokeRect(t.x - 2, t.y - labelSize, w + 4, labelSize + 4);
    }
    if (hoverSelect.type === "door") {
      const b = doorBounds(hoverSelect.obj);
      ctx.strokeRect(b.x1, b.y1, (b.x2 - b.x1), (b.y2 - b.y1));
    }
  }

  ctx.restore();
  updateInventory();
}

/* ---------- EXPORT ---------- */

function exportPNG() {
  if (!requireNameOrToast()) return;
  // Ensure latest Customer Info text is captured before exporting
  if (typeof syncInfoStateFromPanel === "function") syncInfoStateFromPanel();
  if (typeof syncProjectInfoStateFromPanel === "function") syncProjectInfoStateFromPanel();

  const link = document.createElement("a");
  const fn = (customerInfo && customerInfo.firstName ? String(customerInfo.firstName) : "").trim();
  const ln = (customerInfo && customerInfo.lastName ? String(customerInfo.lastName) : "").trim();

  const safe = (s) => String(s || "")
    .normalize("NFKD")
    .replace(/[^A-Za-z0-9]+/g, "_")
    .replace(/^_+|_+$/g, "");

  const fns = safe(fn);
  const lns = safe(ln);
  const base = (fns && lns) ? (fns + "_" + lns) : (fns || lns || "estimate");

  link.download = base + ".png";
  link.href = canvas.toDataURL("image/png");
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
}


/* ---------- Make functions available to HTML onclick handlers ---------- */
window.setTool = setTool;
window.setColor = setColor;
window.setScale = setScale;
window.setLabelSize = setLabelSize;

window.undo = undo;
window.redo = redo;
window.exportPNG = exportPNG;

window.toggleInventory = toggleInventory;
window.hideInventory = hideInventory;

hideToolbarControls();
syncInfoPanelFromState();
  syncProjectInfoPanelFromState();
  buildColorDropdownUI();
  buildColorDropdownUI();
updatePanelOffsets();

window.fitToScreen = fitToScreen;
window.toggleLabels = toggleLabels;
window.saveProjectJSON = saveProjectJSON;
window.showToast = showToast;
window.toggleSettingsPanel = toggleSettingsPanel;
window.openSettingsPanel = openSettingsPanel;
window.closeSettingsPanel = closeSettingsPanel;
window.setProjectFolder = setProjectFolder;
window.loadProjectFromFolder = loadProjectFromFolder;
window.triggerLoadProject = triggerLoadProject;
window.handleProjectFileSelected = handleProjectFileSelected;
window.openInfoPanel = openInfoPanel;
window.closeInfoPanel = closeInfoPanel;
window.toggleInfoPanel = toggleInfoPanel;
window.setGutterColor = setGutterColor;
window.setDownspoutColor = setDownspoutColor;
window.syncInfoStateFromPanel = syncInfoStateFromPanel;
window.syncInfoPanelFromState = syncInfoPanelFromState;
window.syncProjectInfoStateFromPanel = syncProjectInfoStateFromPanel;
window.syncProjectInfoPanelFromState = syncProjectInfoPanelFromState;

let moveSectionState = {
  lineIds: null,     // Set<number>
  doorIdxs: null,    // Set<number>
  dragging: false,
  start: null,       // {x,y} world
  lineStarts: null,  // Map<number,{x1,y1,x2,y2}>
  doorStarts: null   // Map<number,{x,y}>
};





/* ---------- RIGHT PANEL EXCLUSIVITY (ENFORCED) ----------
   Some legacy functions can still add .open directly.
   This observer guarantees only ONE of the right panels can be open at a time.
*/
(function enforceRightPanelExclusivity(){
  const ids = ["infoPanel","inventoryPanel","settingsPanel"];

  function closeOthers(openId){
    for (const id of ids){
      if (id === openId) continue;
      const el = document.getElementById(id);
      if (el) el.classList.remove("open");
    }
  }

  function scan(){
    for (const id of ids){
      const el = document.getElementById(id);
      if (el && el.classList.contains("open")){
        closeOthers(id);
        break;
      }
    }
  }

  // Run once at startup
  setTimeout(scan, 0);

  const obs = new MutationObserver((mutations) => {
    for (const m of mutations){
      if (m.type !== "attributes" || m.attributeName !== "class") continue;
      const target = m.target;
      if (!target || !target.id) continue;
      if (!ids.includes(target.id)) continue;
      if (target.classList.contains("open")){
        closeOthers(target.id);
      }
    }
  });

  for (const id of ids){
    const el = document.getElementById(id);
    if (el) obs.observe(el, { attributes:true, attributeFilter:["class"] });
  }

  // Final override wrappers (last definitions win)
  window.closeAllRightPanels = function(){
    ids.forEach(id => {
      const el = document.getElementById(id);
      if (el) el.classList.remove("open");
    });
  };
  window.openRightPanel = function(id){
    window.closeAllRightPanels();
    const el = document.getElementById(id);
    if (el) el.classList.add("open");
  };
  window.toggleRightPanel = function(id){
    const el = document.getElementById(id);
    if (!el) return;
    const willOpen = !el.classList.contains("open");
    window.closeAllRightPanels();
    if (willOpen) el.classList.add("open");
  };

  // Back-compat names used in HTML
  window.toggleInfoPanel = () => window.toggleRightPanel("infoPanel");
  window.openInfoPanel = () => window.openRightPanel("infoPanel");
  window.closeInfoPanel = () => { const el=document.getElementById("infoPanel"); if (el) el.classList.remove("open"); };

  window.toggleInventory = () => window.toggleRightPanel("inventoryPanel");
  window.openInventoryPanel = () => window.openRightPanel("inventoryPanel");
  window.closeInventoryPanel = () => { const el=document.getElementById("inventoryPanel"); if (el) el.classList.remove("open"); };

  window.toggleSettingsPanel = () => window.toggleRightPanel("settingsPanel");
  window.openSettingsPanel = () => window.openRightPanel("settingsPanel");
  window.closeSettingsPanel = () => { const el=document.getElementById("settingsPanel"); if (el) el.classList.remove("open"); };
})();


/* Live-clear required name field error state (works even if inputs are created later) */
document.addEventListener("input", (e) => {
  const t = e && e.target;
  if (!t || !t.id) return;
  if (t.id === "ciFirst" || t.id === "ciLast") {
    if (t.value && t.value.trim()) t.classList.remove("req-error");
  }
}, true);


/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>

<script>
// v11.4.5 default tool guard: keep Gutter selected on load
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  try {
    if (typeof tool === "undefined" || tool === "pvc") {
      if (typeof setTool === "function") {
        setTool("line"); // gutter
      } else {
        tool = "line";
        const b = document.getElementById("tool-line");
        if (b) {
          document.querySelectorAll(".tool-btn").forEach(x=>x.classList.remove("active"));
          b.classList.add("active");
        }
      }
    }
  } catch(_) {}
});

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>













<div id="zoom-controls">
  <button id="btn-zoom-in" title="Zoom In">+</button>
  
    <button id="btn-fit" title="Fit to Screen">‚§¢</button>
<button id="btn-zoom-out" title="Zoom Out">‚àí</button>
</div>


<script>
// v11.4.5 Zoom button handlers (uses existing zoom/fit functions)
(function(){
  function zoomAtCenter(f){
    if (typeof canvas === "undefined") return;
    const rect = canvas.getBoundingClientRect();
    const mx = rect.width / 2;
    const my = rect.height / 2;

    const worldX = mx - panX;
    const worldY = my - panY;

    if (typeof saveState === "function") saveState();
    if (typeof scaleWorld === "function") scaleWorld(f);
    if (typeof autoCorners === "function") autoCorners();

    panX = mx - worldX * f;
    panY = my - worldY * f;

    if (typeof redraw === "function") redraw();

    // If dock script exists, refresh dock position
    if (typeof updateZoomDock === "function") updateZoomDock();
  }

  document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
    const zin = document.getElementById("btn-zoom-in");
    const zout = document.getElementById("btn-zoom-out");
    const fit = document.getElementById("btn-fit");

    if (zin) zin.addEventListener("click", () => zoomAtCenter(1.1));
    if (zout) zout.addEventListener("click", () => zoomAtCenter(0.9));
    if (fit) fit.addEventListener("click", () => {
      if (typeof saveState === "function") saveState();
      if (typeof fitToScreen === "function") fitToScreen();
      if (typeof autoCorners === "function") autoCorners();
      if (typeof updateInventory === "function") updateInventory();
      if (typeof redraw === "function") redraw();
      if (typeof updateZoomDock === "function") updateZoomDock();
    });
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>





<!-- Floating center toolbar (visual only; no behavior wired yet) -->
<div id="floatingToolbarWrap" aria-hidden="true">
  
<div id="floatingToolbar">
  <div class="ft-btn" id="ft-select" role="button" tabindex="0" title="Selector">
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAxklEQVR4nO3RsQqBURjG8b8+ycZATK7AxbC7DJtbsJvsJuUKhJTPYGS0mIwGg8ErdYa3L0Vy3tfwPfXU6Vl+53Qgzx9lDWyBujUsoXug6QGLNS5euHjh4oWLFy5veoiFixcuXrh44eKFyxdNveBlbHgKFH+BvEoWGwGncL4BLSJFVGdAAgzUNowNL4By2GrANewXoBIDXgEboJrZx+pSfQzTBu4Bfv55yRKfq1f3LOGugneWcAIcFd6wxDvAGZgABUs4D5/kAfCYopVhLz+nAAAAAElFTkSuQmCC" alt="Select"/>
  </div>
  <div class="ft-btn" id="ft-delete" role="button" tabindex="0" title="Delete">
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAEFklEQVR4nO2aSWxOURTHT4k2VNKEmsUs5tpQiVqoBRXTgkQN3aiEmoWFkpSk1FQxbVAUMSxQimChkiJRJEoVC0MFRZEY2koq9MlJ/i9pXs653/e99756Ev/kbPp7995zXu8795zbEvmnWCLaSkTviMgKYdVEtBljAqctYQTgtDwKoKrh3Ogwnk1p8psJnCxYtJ73pI5EdI6I6l1sG7+snoiK4Itr3fiLAVgOK43U+Q5EdJSIvgbAecth7NMRIkoMFQQ/8DYADlsh7A0RtTcFcigATlphWoEpkM8BcNAK0z6ZArkcAAetMI19/a9/TicCsHUsxY5HEsiGADhsKbY+kkDmBMBhS7HZkQQyUpnkLhFl4ECSeAMRLUF9pjnCddNSIvqp8NdY457C2bewlaBMsgx8h8IrwYcbAknCM5UKzwdfrnD2LSJ9FCbZDrZYWeQ5eB9DIL3xzAuFLwLPF1gNudAtYaKzYBMVJ96DdzIEYpfjHxSeBl4ksJtuAikUJioHG6g48R28rSGQeDxTq/AB4A8EdthNIGsNjsYR0W+B889iYI0Cb2zCtfFxWOObwLPdBDJDeWN2L6BlrtbgUldZB9bGkLHsnkji08mFtMyTHKJ7TDQki5oQjpaCjwqR8SJSvLI90sGPKIv1An8pMM5UhMwljS0En6VsS/v7ilhSt8jfDqFUkJwZAv5IYBVgQ5WxOeDrBMZb2bWuGzqzjBBbr0xgt0NsnbngBwVW4iWQ/YYJxyjOpIKXCOwa2DhlbIrhBe7zEshqYcIqsK6KM1PAiwV2HmyqMrYL+CuBrfISiLTgL1w+xygp1k4GJwXGfY72Mf/AnK2whvaCXGmQ8ub6gT8RWCZYgcAOgM0X2GOw/sqaXE24VqzydsaDXzJUyLsEttNQ2V4Em2DYBZ4kVakLwfYY0vNGgeUa0utusCxDVe1JV4WJ+Q86rJUC2wSWLbA1YHkCWwG2TWBX/AhkrzDxabBpAuMtRdhiTsadIeHtOxknFtYZgfFv3rMkh+6DJRkOzEyBzTMceMPAyg0vwJPSlFtxre/gtEtIw042E+yUwHguUv4KwAnAs/oq6bC9UuXyQciaLIyZBHZBqYoTlbW4dfaslrgd0W4zypQSJlUYM1YpQewaLFkY0wAffNFTwzZxnuBlBqfs4O8oJ366MIYPXd/k3ApN207necHlO6Gcd44ZrFwF5Rra62I/A8k3lBvO7MQNFaunMKYHWJWSzQoMV1C+aIGwwEMiaoF7KGdfnqBsrRFgdY6fZ2GuCmEMr+2bpA/XQgcpJYIvynVPLZj0Qdv/cKD1N76ou7JIc1g3PwOJEbZDc1g91vZVUukQbSungPz3j1fLiUYgnQ23i9GwZ0TULhqBsPhs4JNcu0n3w3juY5F+5H8AdSNFfe+58TAAAAAASUVORK5CYII=" alt="Delete"/>
  </div>
  <div class="ft-btn" id="ft-text" role="button" tabindex="0" title="Text">T</div>
  <div class="ft-sep"></div>
  <div class="ft-btn" id="ft-undo" role="button" tabindex="0" title="Undo">‚Ü∂</div>
  <div class="ft-btn" id="ft-redo" role="button" tabindex="0" title="Redo">‚Ü∑</div>
  <div class="ft-btn" id="ft-labels" role="button" tabindex="0" title="Toggle Labels">
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAyCAYAAAAeP4ixAAAACXBIWXMAAAsTAAALEwEAmpwYAAAC10lEQVR4nO2YyWsUQRSHPzHiitFLOxrjFtxANHrwoleXkyuK4E0UPIp4EEEFRVH/AEkwehH3gyDoTTxoREElLkRckIg7uEQT0Yhm5MkLDE1XddV0D+kx/YO6DF3vV1/X9Kv3CnLlyjWgdQ94ABSoct0HisDjaocJgEcK8wSYQBUryGEyqiCHyagKmsVs2WwesB04qen7LfAD+Al80Gx4GtgBNAKDyBDMNOAQ0KG/+4w3wBFgVn/DfAT+hBb3BTgKrAKmACOAoQq8DjgGdIXmSIwLwJz+hOkb8vfZDYx2mC/PHAR+RQCdq/QO1QB7gI0GmGVlxFygf69ixEvZpZ6pagZwS01+G2DKLWemAi8N39AdYG5aEFuB7pBB2jALgR4DjOzO5iQAQ4AWS8YRmEUpwuyPyXDNmjS8NBa4GhP4c+jDTgojnp0xntf1OSdNBNodzoCmiLlhmLPAJ+AbcBGYGePd4uD70KWymAQ8dzzMVnik5tJdrLf4r3H0fqEvPFJ1+oDrqSzQlAFz3jJvuoe/1HzjooLc9AgiY5hlQTaYr5Y5ozzX0BoVpNUziJiatNQCI2WNSSPTACnodrkGabAs6ASwyQBzxjKvwcP/GTDeFKje4ztZbVmQZJV3Bhhbal7r6N3ukrnqNMXFBZMq1iZ5W8eBJR4wTQ6+bdroOUkOnRsxAaVcH+Ma0AGm1uFAvFKG579yoDkm8D7foBaYvRafXm3eBpNAW7RwizLo0YIvKcxyS9H4HdhASpJS+q7BqEM7wSQwpnG7Ek1WjTY7UbsjzdH8FGG6gZ2VaKxKJW/oUoS5tK0HHFvdWkMLUAQux9RjqWuxmvaGgLq0il2vFw6SNIYDk4GVmrY7K9CcJdZs4DDw2uNU7htPFTAzMOhlW6Nevp3Sg+u9XtBJRnoFXNMd2Wb4iAtZgUlDwf90PRvkMBlVkMNkVIWSbCbZkGqHadOr21y5cg1U/QVRBwvnYYFUFAAAAABJRU5ErkJggg==" alt="Labels"/>
  </div>
</div>

</div>


<script>
// v11.4.5 Floating toolbar wiring (uses existing functions; no layout/canvas changes)
(function(){
  function safeCall(fn, args=[]){
    try{ if (typeof fn === "function") return fn.apply(window, args); }catch(e){}
  }

  function bind(id, onActivate){
    const el = document.getElementById(id);
    if (!el) return;
    const stop = (e)=>{ e.preventDefault(); e.stopPropagation(); };
    el.addEventListener("pointerdown", stop, {passive:false});
    el.addEventListener("click", (e)=>{ stop(e); onActivate(); }, {passive:false});
    el.addEventListener("keydown", (e)=>{
      if (e.key === "Enter" || e.key === " "){ stop(e); onActivate(); }
    });
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    bind("ft-select", ()=> safeCall(window.setTool, ["select"]));
    bind("ft-delete", ()=> safeCall(window.setTool, ["eraser"])); // delete uses existing eraser tool
    bind("ft-text",   ()=> safeCall(window.setTool, ["text"]));
    bind("ft-undo",   ()=> safeCall(window.undo, []));
    bind("ft-redo",   ()=> safeCall(window.redo, []));
    bind("ft-labels", ()=> safeCall(window.toggleLabels, []));
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Clear All wiring (Settings panel button)
(function(){
  function doClearAll(){
    // Reset drawing/state collections
    if (typeof lines !== "undefined") { lines = []; }
    if (typeof nextLineId !== "undefined") { nextLineId = 1; }

    if (typeof splashGuards !== "undefined") { splashGuards = []; }
    if (typeof nextSplashId !== "undefined") { nextSplashId = 1; }

    if (typeof downspouts !== "undefined") { downspouts = []; }
    if (typeof texts !== "undefined") { texts = []; }
    if (typeof doors !== "undefined") { doors = []; }
    if (typeof corners !== "undefined") { corners = []; }

    // Clear covers selections
    if (typeof coverTRexLineIds !== "undefined" && coverTRexLineIds && coverTRexLineIds.clear) coverTRexLineIds.clear();
    if (typeof coverDoubleProLineIds !== "undefined" && coverDoubleProLineIds && coverDoubleProLineIds.clear) coverDoubleProLineIds.clear();

    // Clear PVC selections
    if (typeof pvcWedgesLineIds !== "undefined" && pvcWedgesLineIds && pvcWedgesLineIds.clear) pvcWedgesLineIds.clear();
    if (typeof pvcAddBoardLineIds !== "undefined" && pvcAddBoardLineIds && pvcAddBoardLineIds.clear) pvcAddBoardLineIds.clear();
    if (typeof hoverCoverLineIds !== "undefined") hoverCoverLineIds = null;
    if (typeof hoverPVCLineIds !== "undefined") hoverPVCLineIds = null;

    // Inventory misc items (keep price list/settings intact)
    if (typeof miscItems !== "undefined") { miscItems = []; }

    // Undo/redo
    if (typeof undoStack !== "undefined") undoStack = [];
    if (typeof redoStack !== "undefined") redoStack = [];

    // Clear active interactions
    if (typeof drawingLine !== "undefined") drawingLine = null;
    if (typeof drawingSplash !== "undefined") drawingSplash = null;
    if (typeof isPanning !== "undefined") isPanning = false;
    if (typeof draggingPoint !== "undefined") draggingPoint = null;
    if (typeof draggingText !== "undefined") draggingText = null;

    // Reset tool to default gutter
    if (typeof setTool === "function") setTool("line");
    else if (typeof tool !== "undefined") tool = "line";

    // Refresh UI
    if (typeof autoCorners === "function") autoCorners();
    if (typeof updateInventory === "function") updateInventory();
    if (typeof redraw === "function") redraw();
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    const btn = document.getElementById("btn-clear-all");
    if (!btn) return;

    btn.addEventListener("click", (e)=>{
      e.preventDefault();
      e.stopPropagation();
      const ok = window.confirm("Clear all drawings and inventory items? This cannot be undone.");
      if (!ok) return;
      doClearAll();
    });
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Legacy top toolbar toggle (Settings)
(function(){
  const KEY = "showTopToolbar";
  function apply(val){
    document.body.classList.toggle("showTopToolbar", !!val);
  }
  document.addEventListener("DOMContentLoaded", ()=>{
    const chk = document.getElementById("chkShowTopToolbar");
    const saved = localStorage.getItem(KEY);
    const initial = saved === "1"; // default false
    apply(initial);
    if (chk) chk.checked = initial;

    if (chk){
      chk.addEventListener("change", ()=>{
        const v = !!chk.checked;
        localStorage.setItem(KEY, v ? "1" : "0");
        apply(v);
        // refresh dock positions just in case layout shifts slightly
        if (typeof updateZoomDock === "function") updateZoomDock();
        if (typeof updateZoomControlsOffset === "function") updateZoomControlsOffset();
        if (typeof redraw === "function") redraw();
      });
    }
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Floating toolbar active-state sync
(function(){
  function clearActive(){
    document.querySelectorAll('#floatingToolbar .ft-btn.active:not(#ft-labels)')
      .forEach(b=>b.classList.remove('active'));
  }

  function setActiveByTool(tool){
    clearActive();
    switch(tool){
      case "select":
        document.getElementById("ft-select")?.classList.add("active");
        break;
      case "eraser":
        document.getElementById("ft-delete")?.classList.add("active");
        break;
      case "text":
        document.getElementById("ft-text")?.classList.add("active");
        break;
    }
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    // Wrap setTool so toolbar reflects changes from anywhere
    if (typeof window.setTool === "function" && !window.__setToolWrapped){
      const orig = window.setTool;
      window.setTool = function(tool){
        const r = orig.apply(this, arguments);
        setActiveByTool(tool);
        return r;
      };
      window.__setToolWrapped = true;
    }

    // Initial state
    if (typeof window.tool !== "undefined"){
      setActiveByTool(window.tool);
      document.getElementById("ft-labels")?.classList.toggle("active", !(window.showLabels ?? true));
    }
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Dock toast notifications above floating bottom toolbar
(function(){
  function dockToast(){
    const tc = document.getElementById("toastContainer");
    const barWrap = document.getElementById("floatingToolbarWrap");
    if (!tc) return;

    if (barWrap){
      const r = barWrap.getBoundingClientRect();
      if (r && r.top > 0){
        const gap = 10;
        const bottomPx = Math.max(18, Math.round(window.innerHeight - r.top + gap));
        tc.style.bottom = bottomPx + "px";
        return;
      }
    }
    // fallback
    tc.style.bottom = "96px";
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    dockToast();
    window.addEventListener("resize", dockToast);
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Right panels closable again (Option A: auto-open only when needed)
(function(){
  const IDS = ["inventoryPanel","settingsPanel","infoPanel","projectPanel"];

  function closeAll(){
    IDS.forEach(id=>document.getElementById(id)?.classList.remove("open"));
  }

  window.closeAllRightPanels = function(){
    closeAll();
    if (typeof updateZoomDock === "function") updateZoomDock();
  };

  window.openRightPanel = function(id){
    closeAll();
    document.getElementById(id)?.classList.add("open");
    if (typeof updateZoomDock === "function") updateZoomDock();
  };

  window.closeRightPanel = function(id){
    document.getElementById(id)?.classList.remove("open");
    if (typeof updateZoomDock === "function") updateZoomDock();
  };

  window.toggleRightPanel = function(id){
    const el = document.getElementById(id);
    if (!el) return;
    const isOpen = el.classList.contains("open");
    closeAll();
    if (!isOpen) el.classList.add("open");
    if (typeof updateZoomDock === "function") updateZoomDock();
  };

  // Panel-specific helpers used by existing buttons
  window.openInventoryPanel = function(){ window.openRightPanel("inventoryPanel"); };
  window.openSettingsPanel = function(){ window.openRightPanel("settingsPanel"); };
  window.openInfoPanel = function(){ window.openRightPanel("infoPanel"); };
  window.openProjectPanel = function(){ window.openRightPanel("projectPanel"); };

  window.closeInventoryPanel = function(){ window.closeRightPanel("inventoryPanel"); };
  window.closeSettingsPanel = function(){ window.closeRightPanel("settingsPanel"); };
  window.closeInfoPanel = function(){ window.closeRightPanel("infoPanel"); };
  window.closeProjectPanel = function(){ window.closeRightPanel("projectPanel"); };

  window.toggleInventoryPanel = function(){ window.toggleRightPanel("inventoryPanel"); };
  window.toggleSettingsPanel = function(){ window.toggleRightPanel("settingsPanel"); };
  window.toggleInfoPanel = function(){ window.toggleRightPanel("infoPanel"); };
  window.toggleProjectPanel = function(){ window.toggleRightPanel("projectPanel"); };

  document.addEventListener("DOMContentLoaded", ()=>{
    // Default: all closed (Option A)
    closeAll();
    if (typeof updateZoomDock === "function") updateZoomDock();
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Info Tabs Overlay controller (keeps existing panels intact so inventory stays stable)
(function(){
  const overlay = () => document.getElementById("infoTabsOverlay");
  const btn = (id)=>document.getElementById(id);

  function setActive(tab){
    ["customer","project","inventory","upgrades","settings"].forEach(t=>{
      btn("it"+t.charAt(0).toUpperCase()+t.slice(1))?.classList.toggle("active", t===tab);
    });
  }

  function anyOpen(){
    return ["infoPanel","projectPanel","inventoryPanel","upgradesPanel","settingsPanel"].some(id=>document.getElementById(id)?.classList.contains("open"));
  }

  function showOverlay(show){
    const o = overlay();
    if (!o) return;
    o.classList.toggle("show", !!show);
    document.body.classList.toggle("infoTabsShown", !!show);
  }

  // Ensure we have closeAllRightPanels / openRightPanel / closeRightPanel / toggleRightPanel
  if (typeof window.closeAllRightPanels !== "function") {
    window.closeAllRightPanels = function(){
      ["infoPanel","projectPanel","inventoryPanel","upgradesPanel","settingsPanel"].forEach(id=>document.getElementById(id)?.classList.remove("open"));
      if (typeof updateZoomDock === "function") updateZoomDock();
    };
  }
  if (typeof window.openRightPanel !== "function") {
    window.openRightPanel = function(id){
      window.closeAllRightPanels();
      document.getElementById(id)?.classList.add("open");
      if (typeof updateZoomDock === "function") updateZoomDock();
    };
  }
  if (typeof window.closeRightPanel !== "function") {
    window.closeRightPanel = function(id){
      document.getElementById(id)?.classList.remove("open");
      if (typeof updateZoomDock === "function") updateZoomDock();
    };
  }
  if (typeof window.toggleRightPanel !== "function") {
    window.toggleRightPanel = function(id){
      const el=document.getElementById(id);
      if (!el) return;
      const isOpen=el.classList.contains("open");
      window.closeAllRightPanels();
      if (!isOpen) el.classList.add("open");
      if (typeof updateZoomDock === "function") updateZoomDock();
    };
  }

  window.openInfoTabs = function(tab){
    const which = (tab||"customer").toLowerCase();
    if (which === "customer") window.openRightPanel("infoPanel");
    else if (which === "project") {
      const p = document.getElementById("projectPanel");
      if (p) window.openRightPanel("projectPanel");
      else if (typeof showToast === "function") showToast("Project panel not available in this build.");
      else alert("Project panel not available in this build.");
    }
    else if (which === "inventory") window.openRightPanel("inventoryPanel");
    else if (which === "settings") window.openRightPanel("settingsPanel");
    setActive(which);
    showOverlay(true);
  };

  window.closeInfoTabs = function(){
    window.closeAllRightPanels();
    showOverlay(false);
  };

  window.toggleInfoTabs = function(){
    if (anyOpen()) window.closeInfoTabs();
    else window.openInfoTabs("customer");
  };

  // Back-compat for existing calls
  window.toggleInfoPanel = function(){ window.openInfoTabs("customer"); };
  window.openInfoPanel = function(){ window.openInfoTabs("customer"); };
  window.toggleProjectPanel = function(){ window.openInfoTabs("project"); };
  window.openProjectPanel = function(){ window.openInfoTabs("project"); };
  window.toggleInventory = function(){ window.openInfoTabs("inventory"); };
  window.toggleInventoryPanel = function(){ window.openInfoTabs("inventory"); };
  window.openInventoryPanel = function(){ window.openInfoTabs("inventory"); };
  window.closeProjectPanel = function(){ window.closeRightPanel("projectPanel"); showOverlay(anyOpen()); };
  window.closeInfoPanel = function(){ window.closeRightPanel("infoPanel"); showOverlay(anyOpen()); };
  window.closeInventoryPanel = function(){ window.closeRightPanel("inventoryPanel"); showOverlay(anyOpen()); };

  // Keep overlay visibility synced if panels opened/closed by other code
  function sync(){
    if (anyOpen()) showOverlay(true);
    else showOverlay(false);
  }
  document.addEventListener("DOMContentLoaded", ()=>{
    sync();
    window.addEventListener("resize", sync);
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Customer input masks
(function(){
  function maskPhone(v){
    const d = v.replace(/\D/g,'').slice(0,10);
    const p1 = d.slice(0,3);
    const p2 = d.slice(3,6);
    const p3 = d.slice(6,10);
    if (d.length > 6) return `(${p1})${p2}-${p3}`;
    if (d.length > 3) return `(${p1})${p2}`;
    if (d.length > 0) return `(${p1}`;
    return '';
  }
  function maskZip(v){
    return v.replace(/\D/g,'').slice(0,5);
  }
  document.addEventListener("DOMContentLoaded", ()=>{
    const phone = document.getElementById("custPhone");
    const zip = document.getElementById("custZip");
    if (phone){
      phone.addEventListener("input", e=>{
        const pos = e.target.selectionStart;
        e.target.value = maskPhone(e.target.value);
        try{ e.target.setSelectionRange(e.target.value.length, e.target.value.length); }catch{}
      });
    }
    if (zip){
      zip.addEventListener("input", e=>{
        e.target.value = maskZip(e.target.value);
      });
    }
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;

</script>


<script>
// v11.4.5 Customer input masks (Phone + Zip)
(function(){
  function maskPhone(v){
    const d = (v||"").replace(/\D/g,'').slice(0,10);
    const a = d.slice(0,3), b = d.slice(3,6), c = d.slice(6,10);
    if (d.length >= 7) return `(${a})${b}-${c}`;
    if (d.length >= 4) return `(${a})${b}`;
    if (d.length >= 1) return `(${a}`;
    return '';
  }
  function maskZip(v){
    return (v||"").replace(/\D/g,'').slice(0,5);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    const phone = document.getElementById("ciPhone");
    const zip = document.getElementById("ciZip");

    if (phone){
      phone.setAttribute("inputmode","tel");
      phone.setAttribute("placeholder","(###)###-####");
      phone.addEventListener("input", (e)=>{
        const el = e.target;
        const before = el.value;
        const after = maskPhone(before);
        el.value = after;
        // Keep caret at end (simplest + stable on mobile)
        try{ el.setSelectionRange(after.length, after.length); }catch(_){}
      });
    }

    if (zip){
      zip.setAttribute("inputmode","numeric");
      zip.setAttribute("placeholder","#####");
      zip.addEventListener("input", (e)=>{
        e.target.value = maskZip(e.target.value);
      });
    }
  });
})();

/* --- Project Panel: Choose User (safe, UI-only; does not affect canvas/tools) --- */
window.__projectUser = window.__projectUser || ""; // "user1" | "user2" | ""
function __applyProjectUserUI(){
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (!b1 || !b2) return;
  b1.classList.toggle("active", window.__projectUser === "user1");
  b2.classList.toggle("active", window.__projectUser === "user2");
}
function __setProjectUser(u){
  const next = (u === "user2") ? "user2" : "user1";
  const prev = window.__projectUser || "";
  if (prev === next) { __applyProjectUserUI(); return; }
  window.__projectUser = next;
  __applyProjectUserUI();
  try{ if (typeof showToast === "function") showToast("User selected"); }catch(_){ }
}
document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ }
  const b1 = document.getElementById("projUser1");
  const b2 = document.getElementById("projUser2");
  if (b1 && !b1.dataset.bound) {
    b1.dataset.bound = "1";
    b1.addEventListener("click", () => __setProjectUser("user1"));
  }
  if (b2 && !b2.dataset.bound) {
    b2.dataset.bound = "1";
    b2.addEventListener("click", () => __setProjectUser("user2"));
  }
  __applyProjectUserUI();
});


document.addEventListener("DOMContentLoaded", () => {
  try{ renderCurrentPriceList(); }catch(_){ } try{ buildColorDropdownUI(); }catch(_){}});

window.ENABLE_UPGRADES = window.ENABLE_UPGRADES ?? true;



/* ===== Right panel router patch (ensures only 1 panel open, includes Upgrades) ===== */
(function(){
  const IDS = ["infoPanel","projectPanel","inventoryPanel","upgradesPanel","settingsPanel"];
  window.closeAllRightPanels = function(){
    IDS.forEach(id => document.getElementById(id)?.classList.remove("open"));
    if (typeof updateZoomDock === "function") updateZoomDock();
  };
  window.openRightPanel = function(id){
    window.closeAllRightPanels();
    document.getElementById(id)?.classList.add("open");
    if (typeof updateZoomDock === "function") updateZoomDock();
  };
  window.closeRightPanel = function(id){
    document.getElementById(id)?.classList.remove("open");
    if (typeof updateZoomDock === "function") updateZoomDock();
  };
  window.toggleRightPanel = function(id){
    const el = document.getElementById(id);
    if (!el) return;
    const willOpen = !el.classList.contains("open");
    window.closeAllRightPanels();
    if (willOpen) el.classList.add("open");
    if (typeof updateZoomDock === "function") updateZoomDock();
  };
})();



/* ===== Canonical Right Panel Manager (single source of truth) ===== */
(function(){
  const PANELS = {
    customer: "infoPanel",
    project: "projectPanel",
    inventory: "inventoryPanel",
    upgrades: "upgradesPanel",
    settings: "settingsPanel"
  };
  const TAB_IDS = {
    customer: "itCustomer",
    project: "itProject",
    inventory: "itInventory",
    upgrades: "itUpgrades",
    settings: "itSettings"
  };
  const ALL_PANEL_IDS = Object.values(PANELS);

  function closeAll(){
    ALL_PANEL_IDS.forEach(id => document.getElementById(id)?.classList.remove("open"));
  }
  function setActiveTab(which){
    Object.entries(TAB_IDS).forEach(([k, id]) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.classList.toggle("active", k === which);
    });
  }

  window.RightPanel = {
    panels: PANELS,
    open(which){
      const id = PANELS[which];
      if (!id) return;
      closeAll();
      document.getElementById(id)?.classList.add("open");
      setActiveTab(which);
      if (typeof updateZoomDock === "function") updateZoomDock();
    },
    close(which){
      const id = PANELS[which];
      if (!id) return;
      document.getElementById(id)?.classList.remove("open");
      if (typeof updateZoomDock === "function") updateZoomDock();
    },
    closeAll(){
      closeAll();
      if (typeof updateZoomDock === "function") updateZoomDock();
    }
  };

  // Override legacy router functions to route through the canonical manager.
  window.openRightPanel = function(panelId){
    // panelId may be an actual id like "inventoryPanel"
    const which = Object.keys(PANELS).find(k => PANELS[k] === panelId);
    if (which) window.RightPanel.open(which);
  };
  window.closeRightPanel = function(panelId){
    const which = Object.keys(PANELS).find(k => PANELS[k] === panelId);
    if (which) window.RightPanel.close(which);
  };
  window.closeAllRightPanels = function(){ window.RightPanel.closeAll(); };
  window.toggleRightPanel = function(panelId){
    const which = Object.keys(PANELS).find(k => PANELS[k] === panelId);
    if (!which) return;
    const el = document.getElementById(PANELS[which]);
    const willOpen = el ? !el.classList.contains("open") : True;
    closeAll();
    if (willOpen && el) el.classList.add("open");
    setActiveTab(willOpen ? which : "");
    if (typeof updateZoomDock === "function") updateZoomDock();
  };

  // Override openInfoTabs to use canonical panel names (customer/project/inventory/upgrades/settings)
  window.openInfoTabs = function(which){
    if (!PANELS[which]) return;
    window.RightPanel.open(which);
  };

  // Ensure Upgrades close helper uses canonical manager
  window.closeUpgradesPanel = function(){ window.RightPanel.close("upgrades"); };
})();



/* ===== Right Panel Overlay Sync Patch (restores top tabs visibility) ===== */
(function(){
  const PANELS = { customer:"infoPanel", project:"projectPanel", inventory:"inventoryPanel", upgrades:"upgradesPanel", settings:"settingsPanel" };
  const TAB_IDS = { customer:"itCustomer", project:"itProject", inventory:"itInventory", upgrades:"itUpgrades", settings:"itSettings" };
  const ALL = Object.values(PANELS);

  function anyOpen(){
    return ALL.some(id => document.getElementById(id)?.classList.contains("open"));
  }
  function syncOverlay(){
    const overlay = document.getElementById("infoTabsOverlay");
    const show = anyOpen();
    if (overlay) overlay.classList.toggle("show", show);
    document.body.classList.toggle("infoTabsShown", show);
  }
  function setActive(which){
    Object.entries(TAB_IDS).forEach(([k,id])=>{
      const el=document.getElementById(id);
      if (el) el.classList.toggle("active", k===which);
    });
  }

  // Canonical manager (overrides previous ones)
  window.RightPanel = {
    open(which){
      const id = PANELS[which];
      if (!id) return;
      ALL.forEach(pid => document.getElementById(pid)?.classList.remove("open"));
      document.getElementById(id)?.classList.add("open");
      setActive(which);
      syncOverlay();
      if (typeof updateZoomDock === "function") updateZoomDock();
    },
    close(which){
      const id = PANELS[which];
      if (!id) return;
      document.getElementById(id)?.classList.remove("open");
      setActive(""); // no forced tab when closing one
      syncOverlay();
      if (typeof updateZoomDock === "function") updateZoomDock();
    },
    closeAll(){
      ALL.forEach(pid => document.getElementById(pid)?.classList.remove("open"));
      setActive("");
      syncOverlay();
      if (typeof updateZoomDock === "function") updateZoomDock();
    }
  };

  // Legacy wrappers
  window.openRightPanel = (panelId) => {
    const which = Object.keys(PANELS).find(k => PANELS[k] === panelId);
    if (which) window.RightPanel.open(which);
  };
  window.closeRightPanel = (panelId) => {
    const which = Object.keys(PANELS).find(k => PANELS[k] === panelId);
    if (which) window.RightPanel.close(which);
  };
  window.closeAllRightPanels = () => window.RightPanel.closeAll();
  window.toggleRightPanel = (panelId) => {
    const which = Object.keys(PANELS).find(k => PANELS[k] === panelId);
    if (!which) return;
    const el = document.getElementById(PANELS[which]);
    const willOpen = el ? !el.classList.contains("open") : true;
    window.RightPanel.closeAll();
    if (willOpen) window.RightPanel.open(which);
  };

  window.openInfoTabs = (which) => { if (PANELS[which]) window.RightPanel.open(which); };
  window.closeUpgradesPanel = () => window.RightPanel.close("upgrades");

  // Initial sync (in case something starts open)
  try{ syncOverlay(); }catch(_){}
})();


// ===== Upgrades Calculation =====
(function(){
  function renderUpgrades(){
    try{
      const qtyEl = document.getElementById("inv2x3");
      const amtEl = document.getElementById("upgrade3x4Amount");
      if (!qtyEl || !amtEl) return;

      const qty = parseInt(qtyEl.textContent || "0", 10) || 0;

      // Keep this lightweight legacy updater, but DO NOT clobber the new animated markup.
      // If the new Upgrades Engine has initialized this element, it will contain .upgAmtWrap.
      const wrap = amtEl.querySelector && amtEl.querySelector(".upgAmtWrap");
      const priceSpan = amtEl.querySelector && amtEl.querySelector(".upgAmtPrice");

      // Upgrade price quote: (# of 2x3 downspouts) * $50 (matches the stacked engine's u3x4 calc)
      const total = qty * 50;
      const priceText = "$" + total.toFixed(2);

      if (wrap && priceSpan){
        priceSpan.textContent = priceText;
        // If 3x4 upgrade is accepted (swap is on), keep showing Accepted
        const isAccepted = !!window.__UPG_SWAP_3X4;
        wrap.setAttribute("data-state", isAccepted ? "accepted" : "price");
      } else {
        // Fallback for older markup
        amtEl.textContent = priceText;
      }
    }catch(e){}
  }

  // re-render every time inventory likely updates
  setInterval(renderUpgrades, 500);

  // initial render
  setTimeout(renderUpgrades, 200);
})();




// ===== Upgrades Engine (stacked) =====
(function(){
  const upgrades = [
    {
      key: "u3x4",
      cardId: "upgrade3x4Card",
      amountId: "upgrade3x4Amount",
      calc: () => {
        // Upgrade to 3x4: price = (# of 2x3 downspouts * $50)
        // IMPORTANT: always use RAW counts so the quote doesn't vanish after accepting the swap.
        const raw2 = (typeof window.__RAW_DS_2X3 === "number") ? window.__RAW_DS_2X3 : null;
        if (raw2 !== null) return raw2 * 50;

        const qtyEl = document.getElementById("inv2x3");
        const qty = qtyEl ? (parseInt(qtyEl.textContent || "0", 10) || 0) : 0;
        return qty * 50;
      },
      onToggle: (isOn) => {
        window.__UPG_SWAP_3X4 = !!isOn;
        try{ updateInventory(); }catch(_){}
        try{ redraw(); }catch(_){}
      }
    },
    {
      key: "utrex",
      cardId: "upgradeTRexCard",
      amountId: "upgradeTRexAmount",
      calc: () => {
        // Show cost to add T-Rex ¬Æ to ALL gutters only when no covers exist.
        // Cost = Total Gutter (Upper+Lower) * $9/ft
        const ft = (s) => {
          const n = parseFloat(String(s || "").replace(/[^0-9.\-]/g, ""));
          return isNaN(n) ? 0 : n;
        };

        const lowerEl = document.getElementById("invLowerGutter");
        const upperEl = document.getElementById("invUpperGutter");
        const trexEl  = document.getElementById("invTRex");
        const dpEl    = document.getElementById("invDoublePro");

        const totalGutter = (lowerEl ? ft(lowerEl.textContent) : 0) + (upperEl ? ft(upperEl.textContent) : 0);
        const trexFt = trexEl ? ft(trexEl.textContent) : 0;
        const dpFt   = dpEl ? ft(dpEl.textContent) : 0;

        if (totalGutter <= 0) return 0;
        if (trexFt > 0 || dpFt > 0) return 0;

        const price = 9; // $9/ft (T-Rex ¬Æ)
        return totalGutter * price;
      },
      onToggle: (isOn) => {
        window.__UPG_TREX_ALL = !!isOn;

        // Non-destructive apply: snapshot/restore the cover sets.
        try{
          if (typeof coverTRexLineIds === "undefined") return;
          if (!window.__UPG_SNAPSHOT) window.__UPG_SNAPSHOT = {};
          if (isOn){
            window.__UPG_SNAPSHOT.trex = Array.from(coverTRexLineIds || []);
            window.__UPG_SNAPSHOT.dp   = (typeof coverDoubleProLineIds !== "undefined") ? Array.from(coverDoubleProLineIds || []) : [];

            // Apply T-Rex to all gutter lines (exclude Clean/CleanPro kinds)
            if (coverTRexLineIds && coverTRexLineIds.clear) coverTRexLineIds.clear();
            if (typeof coverDoubleProLineIds !== "undefined" && coverDoubleProLineIds && coverDoubleProLineIds.clear) coverDoubleProLineIds.clear();

            for (const l of (lines || [])){
              if (!l || typeof l.id !== "number") continue;
              if (l.kind === "clean" || l.kind === "cleanpro") continue;
              coverTRexLineIds.add(l.id);
            }

            try{ enforceExclusiveCovers(); }catch(_){}
          } else {
            // restore previous manual selections
            if (coverTRexLineIds && coverTRexLineIds.clear) coverTRexLineIds.clear();
            for (const id of (window.__UPG_SNAPSHOT.trex || [])) coverTRexLineIds.add(id);

            if (typeof coverDoubleProLineIds !== "undefined" && coverDoubleProLineIds){
              if (coverDoubleProLineIds.clear) coverDoubleProLineIds.clear();
              for (const id of (window.__UPG_SNAPSHOT.dp || [])) coverDoubleProLineIds.add(id);
            }
            try{ enforceExclusiveCovers(); }catch(_){}
          }
        }catch(_){}

        try{ updateInventory(); }catch(_){}
        try{ redraw(); }catch(_){}
      }
    },
    {
      key: "udp",
      cardId: "upgradeDoubleProCard",
      amountId: "upgradeDoubleProAmount",
      calc: () => {
        // Upgrade to Double PRO ¬Æ
        // - If no covers (no T-Rex ¬Æ and no Double PRO ¬Æ): cost = total gutter ft * $15
        // - If T-Rex ¬Æ exists: cost = total gutter ft * $6
        // - If already Double PRO ¬Æ: cost = $0
        const ft = (s) => {
          const n = parseFloat(String(s || "").replace(/[^0-9.\-]/g, ""));
          return isNaN(n) ? 0 : n;
        };

        const lowerEl = document.getElementById("invLowerGutter");
        const upperEl = document.getElementById("invUpperGutter");
        const trexEl  = document.getElementById("invTRex");
        const dpEl    = document.getElementById("invDoublePro");

        const totalGutter = (lowerEl ? ft(lowerEl.textContent) : 0) + (upperEl ? ft(upperEl.textContent) : 0);
        const trexFt = trexEl ? ft(trexEl.textContent) : 0;
        const dpFt   = dpEl ? ft(dpEl.textContent) : 0;

        if (totalGutter <= 0) return 0;
        if (dpFt > 0) return 0;

        if (trexFt > 0) return totalGutter * 6;
        return totalGutter * 15;
      },
      onToggle: (isOn) => {
        window.__UPG_DP_ALL = !!isOn;

        try{
          if (typeof coverDoubleProLineIds === "undefined") return;
          if (!window.__UPG_SNAPSHOT) window.__UPG_SNAPSHOT = {};
          if (isOn){
            window.__UPG_SNAPSHOT.dp   = Array.from(coverDoubleProLineIds || []);
            window.__UPG_SNAPSHOT.trex = (typeof coverTRexLineIds !== "undefined") ? Array.from(coverTRexLineIds || []) : [];

            if (coverDoubleProLineIds && coverDoubleProLineIds.clear) coverDoubleProLineIds.clear();
            if (typeof coverTRexLineIds !== "undefined" && coverTRexLineIds && coverTRexLineIds.clear) coverTRexLineIds.clear();

            for (const l of (lines || [])){
              if (!l || typeof l.id !== "number") continue;
              if (l.kind === "clean" || l.kind === "cleanpro") continue;
              coverDoubleProLineIds.add(l.id);
            }

            try{ enforceExclusiveCovers(); }catch(_){}
          } else {
            if (coverDoubleProLineIds && coverDoubleProLineIds.clear) coverDoubleProLineIds.clear();
            for (const id of (window.__UPG_SNAPSHOT.dp || [])) coverDoubleProLineIds.add(id);

            if (typeof coverTRexLineIds !== "undefined" && coverTRexLineIds){
              if (coverTRexLineIds.clear) coverTRexLineIds.clear();
              for (const id of (window.__UPG_SNAPSHOT.trex || [])) coverTRexLineIds.add(id);
            }
            try{ enforceExclusiveCovers(); }catch(_){}
          }
        }catch(_){}

        try{ updateInventory(); }catch(_){}
        try{ redraw(); }catch(_){}
      }
    }
  
    ,
    {
      key: "ugcp",
      cardId: "upgradeGutterCleanProCard",
      amountId: "upgradeGutterCleanProAmount",
      calc: () => {
        // Upgrade to Gutter Clean PRO ¬Æ: price = (RAW Gutter Clean ft) * $5/ft
        const raw = (typeof window.__RAW_GC_FT === "number") ? window.__RAW_GC_FT : null;
        if (raw !== null) return raw * 5;

        const ftEl = document.getElementById("invGutterClean");
        const ft = ftEl ? (parseFloat((ftEl.textContent || "0").replace(/[^0-9.\-]/g,"")) || 0) : 0;
        return ft * 5;
      },
      onToggle: (isOn) => {
        window.__UPG_GCP_ALL = !!isOn;

        try{
          if (!window.__UPG_SNAPSHOT) window.__UPG_SNAPSHOT = {};
          if (isOn){
            // Snapshot current tool + kinds for clean/cleanpro lines
            window.__UPG_SNAPSHOT.gcp = {
              toolPrev: (typeof tool !== "undefined") ? tool : null,
              kinds: (lines || []).filter(l => l && (l.kind === "clean" || l.kind === "cleanpro") && typeof l.id === "number")
                                 .map(l => ({id:l.id, kind:l.kind}))
            };

            // Capture RAW gutter clean ft (before conversion)
            let rawFt = 0;
            for (const l of (lines || [])){
              if (!l || l.kind !== "clean") continue;
              rawFt += dist(l);
            }
            window.__RAW_GC_FT = rawFt;

            // Convert existing Gutter Clean lines -> Clean PRO
            for (const l of (lines || [])){
              if (!l) continue;
              if (l.kind === "clean") l.kind = "cleanpro";
            }

            // Make new "Gutter Clean" draws use Clean PRO while accepted
            try{ setTool("guttercleanpro"); }catch(_){}
          } else {
            // Restore kinds
            const snap = window.__UPG_SNAPSHOT.gcp;
            if (snap && Array.isArray(snap.kinds)){
              const map = new Map(snap.kinds.map(o => [o.id, o.kind]));
              for (const l of (lines || [])){
                if (!l || typeof l.id !== "number") continue;
                if (map.has(l.id)) l.kind = map.get(l.id);
              }
            }
            // Restore tool
            try{
              if (snap && snap.toolPrev) setTool(snap.toolPrev);
            }catch(_){}
            window.__RAW_GC_FT = null;
          }
        }catch(_){}

        try{ updateInventory(); }catch(_){}
        try{ redraw(); }catch(_){}
      }
    }
];

  const selected = new Set(); // stacked selections
  const acceptedPrice = {};   // key -> captured price at acceptance time
  const totalEl = document.getElementById("upgradeTotalAmount");
  if (!totalEl) return;

  function fmtMoney(v){
    return "$" + (Math.round(v * 100) / 100).toFixed(2);
  }
  function pressAnim(card){
    card.classList.add("upgradeCard--pressed");
    setTimeout(()=>card.classList.remove("upgradeCard--pressed"), 130);
  }

  // Amount display helper (animated: price <-> Accepted)
  function ensureAmountMarkup(amtEl){
    if (!amtEl) return;
    if (amtEl.dataset && amtEl.dataset.upgAmtReady === "1") return;

    const initial = (amtEl.textContent || "").trim() || "$0.00";
    amtEl.innerHTML =
      '<span class="upgAmtWrap" data-state="price">' +
        '<span class="upgAmtPrice">'+ initial +'</span>' +
        '<span class="upgAmtAccepted">Accepted</span>' +
      '</span>';
    amtEl.dataset.upgAmtReady = "1";
  }
  function setAmountState(amtEl, state, priceText){
    ensureAmountMarkup(amtEl);
    const wrap = amtEl.querySelector(".upgAmtWrap");
    const price = amtEl.querySelector(".upgAmtPrice");
    if (price && typeof priceText === "string") price.textContent = priceText;
    if (wrap) wrap.setAttribute("data-state", state);
  }

  function updateAmounts(){
    for (const u of upgrades){
      const amtEl = document.getElementById(u.amountId);
      const card  = document.getElementById(u.cardId);
      if (!amtEl || !card) continue;

      const isSel = selected.has(u.key);
      const val = u.calc ? (u.calc() || 0) : 0;

      // Card visibility rule:
      // - If not selected and value is 0 => hide
      // - If selected => always show (so you can un-click)
      if (!isSel && val <= 0){
        card.style.display = "none";
      } else {
        card.style.display = "flex";
      }

      if (isSel){
        // Show Accepted (animated), but keep the captured total separately.
        setAmountState(amtEl, "accepted", fmtMoney(acceptedPrice[u.key] || val || 0));
      } else {
        setAmountState(amtEl, "price", fmtMoney(val));
      }
    }
  }

  function updateTotal(){
    let total = 0;
    for (const key of selected){
      total += Number(acceptedPrice[key] || 0);
    }
    totalEl.textContent = fmtMoney(total);
  }

  function toggleUpgrade(u){
    const card = document.getElementById(u.cardId);
    if (card) pressAnim(card);

    const isSelected = selected.has(u.key);

    // Mutual exclusivity: T-Rex (utrex) and Double PRO (udp) cannot both be selected.
    if (!isSelected && (u.key === "utrex" || u.key === "udp")){
      const otherKey = (u.key === "utrex") ? "udp" : "utrex";
      if (selected.has(otherKey)){
        selected.delete(otherKey);
        delete acceptedPrice[otherKey];

        const other = upgrades.find(x => x.key === otherKey);
        if (other){
          const otherCard = document.getElementById(other.cardId);
          if (otherCard) otherCard.classList.remove("upgradeCard--selected");
          try{ if (typeof other.onToggle === "function") other.onToggle(false); }catch(_){}
        }
      }
    }

    if (isSelected){
      selected.delete(u.key);
      delete acceptedPrice[u.key];
      try{ if (typeof u.onToggle === "function") u.onToggle(false); }catch(_){}
    } else {
      selected.add(u.key);
      const v = u.calc ? (u.calc() || 0) : 0;
      acceptedPrice[u.key] = v;
      try{ if (typeof u.onToggle === "function") u.onToggle(true); }catch(_){}
    }

    if (card) card.classList.toggle("upgradeCard--selected", selected.has(u.key));
    updateAmounts();
    updateTotal();
  }

  function bind(){
    for (const u of upgrades){
      const card = document.getElementById(u.cardId);
      if (!card) continue;
      card.addEventListener("click", ()=>toggleUpgrade(u));
    }
  }

  bind();
  updateAmounts();
  updateTotal();

  // keep amounts + total synced as inventory changes (prices can change if the underlying job changes)
  setInterval(()=>{
    updateAmounts();
    updateTotal();
  }, 500);
})();

/* ===== Auto-size Proposal Template box to show full content ===== */
function autosizeProposalTemplates(){
  const ta = document.getElementById("piProposalTemplates");
  if (!ta) return;
  ta.style.height = "auto";
  ta.style.height = ta.scrollHeight + "px";
  ta.style.resize = "none";
}

(function(){
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", autosizeProposalTemplates);
  } else {
    autosizeProposalTemplates();
  }

  const _open = window.openRightPanel;
  if (typeof _open === "function") {
    window.openRightPanel = function(id){
      _open(id);
      if (id === "projectPanel") setTimeout(autosizeProposalTemplates, 0);
    };
  }
  const _toggle = window.toggleRightPanel;
  if (typeof _toggle === "function") {
    window.toggleRightPanel = function(id){
      _toggle(id);
      if (id === "projectPanel") setTimeout(autosizeProposalTemplates, 0);
    };
  }
})();


function openEstimatePreview(){
  try{ renderEstimatePreview(); }catch(e){ console.error(e); }
  const m=document.getElementById("estimatePreviewModal");
  if(m) m.classList.remove("hidden");
}
function closeEstimatePreview(){
  const m = document.getElementById("estimatePreviewModal");
  if (m) m.classList.add("hidden");
}
function _getCanvasDataURL(){
  const c = document.getElementById("canvas");
  if (!c) return "";
  try{ return c.toDataURL("image/png"); }catch(_){ return ""; }
}
function _safeText(v){ return (v==null) ? "" : String(v); }

function buildEstimateLineItems(){
  const items = [];
  const invPanel = document.getElementById("inventoryPanel") || document;
  const rows = invPanel.querySelectorAll(".invRow");
  rows.forEach(r=>{
    if (!r || r.style.display==="none") return;
    const label = r.querySelector(".label")?.textContent?.trim();
    const val = r.querySelector(".value")?.textContent?.trim();
    if (!label || !val) return;
    items.push({label, qty: val});
  });
  return items;
}

function _getProposalText(){
  const el = document.getElementById("proposalText") || document.getElementById("projectProposal") || document.querySelector('textarea[name="proposal"]');
  return el ? el.value : "";
}

function _pdfEscape(s){
  s = (s==null) ? "" : String(s);
  return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

function _pdfGetProposal(){
  const el =
    document.getElementById("proposalText") ||
    document.getElementById("projectProposal") ||
    document.querySelector('textarea[name="proposal"]') ||
    document.querySelector('textarea[id*="proposal" i]');
  return el ? el.value : "";
}

function _pdfSelectedUpgrades(){
  const cards = Array.from(document.querySelectorAll(".upgradeCard"));
  const out = [];
  for (const card of cards){
    const isSel = card.classList.contains("selected") || card.classList.contains("active") || card.getAttribute("aria-pressed")==="true";
    if (!isSel) continue;
    const title = card.querySelector(".upgradeTitle")?.textContent?.trim() || card.textContent.trim().split("\n")[0];
    let amt = card.dataset.acceptedAmount || "";
    if (!amt){
      const t = card.querySelector(".upgradeAmount")?.textContent?.trim() || "";
      amt = (t && t !== "Accepted") ? t : "";
    }
    out.push({ title, amt });
  }
  return out;
}


function renderEstimatePreview(){
  const host = document.getElementById("estimatePreviewContent");
  if(!host) return;

  const canvas = document.getElementById("canvas");
  let img = "";
  try{ img = canvas ? canvas.toDataURL("image/png") : ""; }catch(e){ img=""; }

  const proposalEl =
    document.getElementById("proposalText") ||
    document.querySelector('textarea[name="proposal"]') ||
    document.querySelector('textarea[id*="proposal" i]');

  const proposal = proposalEl ? proposalEl.value : "";

  const upgradesTotal = document.getElementById("upgradesTotalValue")?.textContent || "";

  const cards = Array.from(document.querySelectorAll(".upgradeCard"));
  const selected = cards.filter(c =>
    c.classList.contains("selected") ||
    c.classList.contains("active") ||
    c.getAttribute("aria-pressed")==="true"
  );

  let upgradesHtml = "";
  if(selected.length){
    upgradesHtml = "<ul>" + selected.map(card=>{
      const title = card.querySelector(".upgradeTitle")?.textContent?.trim() ||
                    card.textContent.trim().split("\n")[0];
      let amt = card.dataset.acceptedAmount || "";
      if(!amt){
        const t = card.querySelector(".upgradeAmount")?.textContent?.trim() || "";
        amt = (t && t!=="Accepted") ? t : "";
      }
      return "<li style='display:flex;justify-content:space-between;'>" +
             "<span>"+title+"</span><span>"+amt+"</span></li>";
    }).join("") + "</ul>";
  }else{
    upgradesHtml = "<div style='font-style:italic;color:#777;'>No upgrades selected</div>";
  }

  host.innerHTML =
    "<div class='pdfRoot' id='pdfTemplateRoot'>" +

      "<div class='pdfHeader' style='display:flex;justify-content:space-between;border-bottom:2px solid #5fb2c7;padding-bottom:10px;margin-bottom:15px;'>" +
        "<div>" +
          "<div style='font-size:24px;font-weight:800;'>Bethlehem Seamless Gutters</div>" +
        "</div>" +
        "<div style='text-align:right;font-size:13px;'>" +
          "<div style='font-weight:700;'>518-301-3299</div>" +
          "<div>Submitted: 02/13/2026</div>" +
        "</div>" +
      "</div>" +

      "<div class='pdfGrid' style='display:grid;grid-template-columns:1fr 1fr;gap:20px;'>" +

        "<div style='border:1px solid #ddd;padding:10px;border-radius:8px;'>" +
          (img ? "<img src='"+img+"' style='max-width:100%;'>" : "<div>No drawing</div>") +
        "</div>" +

        "<div>" +
          "<div style='border:1px solid #ddd;padding:10px;border-radius:8px;margin-bottom:15px;'>" +
            "<div style='font-weight:700;margin-bottom:5px;'>Upgrades</div>" +
            upgradesHtml +
            (upgradesTotal ? "<div style='margin-top:10px;font-weight:700;'>Upgrades Total: "+upgradesTotal+"</div>" : "") +
          "</div>" +

          "<div style='border:1px solid #ddd;padding:10px;border-radius:8px;'>" +
            "<div style='font-weight:700;margin-bottom:5px;'>Proposal</div>" +
            "<div>"+proposal.replace(/\n/g,"<br>")+"</div>" +
          "</div>" +
        "</div>" +

      "</div>" +
    "</div>";
}



function downloadEstimatePDF(){
  if(typeof html2pdf==="undefined"){
    alert("PDF library not loaded.");
    return;
  }
  renderEstimatePreview();
  const el = document.getElementById("pdfTemplateRoot");
  if(!el) return;

  html2pdf().set({
    margin:0.35,
    filename:"Estimate.pdf",
    html2canvas:{scale:2,backgroundColor:"#ffffff"},
    jsPDF:{unit:"in",format:"letter",orientation:"portrait"}
  }).from(el).save();
}

</script>
<div id="estimatePreviewModal" class="modalOverlay hidden">
  <div class="estimateModal">
    <div class="estimateTopBar">
      <button class="estBtn" onclick="closeEstimatePreview()">Edit Map</button>
      <div class="estTitle">Preview Estimate</div>
      <button class="estBtn primary" onclick="downloadEstimatePDF()">Download PDF</button>
    </div>
    <div id="estimatePreviewContent" class="estimateContent"></div>
  </div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
<script>
function _pdf_getProposalText(){
  const el = document.getElementById("proposalText") || document.getElementById("projectProposal") || document.querySelector('textarea[name="proposal"]') || document.querySelector('textarea[id*="proposal" i]');
  return el ? el.value : "";
}
function _pdf_getCanvasDataURL(){
  const c = document.getElementById("canvas");
  if (!c) return "";
  try{ return c.toDataURL("image/png"); }catch(_){ return ""; }
}
function _pdf_getMetaText(){
  const name = document.querySelector("#customerPanel input[id*='name' i], #customerPanel input[placeholder*='name' i]")?.value || "";
  const addr = document.querySelector("#customerPanel input[id*='address' i], #customerPanel input[placeholder*='address' i]")?.value || "";
  const city = document.querySelector("#customerPanel input[id*='city' i], #customerPanel input[placeholder*='city' i]")?.value || "";
  const zip = document.querySelector("#customerPanel input[id*='zip' i], #customerPanel input[placeholder*='zip' i]")?.value || "";
  const phone = document.querySelector("#customerPanel input[id*='phone' i], #customerPanel input[placeholder*='phone' i]")?.value || "";
  const dateStr = new Date().toLocaleDateString();
  const parts = [];
  if (name) parts.push(name);
  const line2 = [addr, [city, zip].filter(Boolean).join(" ")].filter(Boolean).join("\n");
  if (line2) parts.push(line2);
  if (phone) parts.push(phone);
  parts.push("Date: " + dateStr);
  return parts.join("\n");
}
function _pdf_getSelectedUpgradeLines(){
  const cards = Array.from(document.querySelectorAll(".upgradeCard"));
  const lines = [];
  for (const c of cards){
    const isSel = c.classList.contains("selected") || c.classList.contains("active") || c.getAttribute("aria-pressed")==="true";
    if (!isSel) continue;
    const title = c.querySelector(".upgradeTitle")?.textContent?.trim() || c.textContent.trim().split("\n")[0];
    let amt = c.dataset.acceptedAmount || "";
    if (!amt){
      const amtEl = c.querySelector(".upgradeAmount");
      const t = amtEl ? amtEl.textContent.trim() : "";
      amt = (t && t !== "Accepted") ? t : "";
    }
    lines.push({title, amt});
  }
  return lines;
}
function renderEstimatePreview(){
  const host = document.getElementById("estimatePreviewContent");
  if (!host) return;

  const img = _pdf_getCanvasDataURL();
  const proposal = _pdf_getProposalText();
  const meta = _pdf_getMetaText();
  const upgrades = _pdf_getSelectedUpgradeLines();
  const upgradesTotal = document.getElementById("upgradesTotalValue")?.textContent || "";

  const upgradesLis = upgrades.length
    ? upgrades.map(u=>`<li><span>${u.title}</span><span>${u.amt || ""}</span></li>`).join("")
    : `<div style="color:#666;font-style:italic;font-size:12px;">No upgrades selected</div>`;

  host.innerHTML = `
    <div class="pdfRoot" id="pdfTemplateRoot">
      <div class="pdfHeader">
        <div class="h1">Seamless Gutter Estimate</div>
        <div class="meta">${meta.replace(/</g,"&lt;")}</div>
      </div>

      <div class="pdfGrid">
        <div class="pdfCanvasBox pdfNoBreak">
          ${img ? `<img src="${img}" alt="Estimate drawing">` : `<div style="color:#666;">(No canvas image)</div>`}
        </div>

        <div class="pdfRight">
          <div class="pdfUpgrades pdfNoBreak">
            <div class="pdfSectionTitle">Upgrades</div>
            ${upgrades.length ? `<ul>${upgradesLis}</ul>` : upgradesLis}
            ${upgradesTotal ? `<div class="pdfTotals"><div>Upgrades Total: ${upgradesTotal}</div></div>` : ``}
          </div>

          <div class="pdfProposal pdfNoBreak">
            <div class="pdfSectionTitle">Proposal</div>
            <div>${(proposal || "").replace(/</g,"&lt;")}</div>
          </div>
        </div>
      </div>
    </div>
  `;
}

function downloadEstimatePDF(){
  try{
    if (typeof html2pdf === "undefined"){
      alert("PDF export library not loaded. Please check internet connection.");
      return;
    }
    renderEstimatePreview();
    const el = document.getElementById("pdfTemplateRoot");
    if (!el) return;

    html2pdf().set({
      margin: 0.35,
      filename: "Estimate.pdf",
      image: { type: "jpeg", quality: 0.98 },
      html2canvas: { scale: 2, useCORS: true },
      jsPDF: { unit: "in", format: "letter", orientation: "portrait" },
      pagebreak: { mode: ["css", "legacy"] }
    }).from(el).save();
  }catch(e){ console.error(e); }
}





/* ===== PDF TEMPLATE OVERRIDES (v12.5.2) ===== */
function _pdfEscape(s){
  s = (s==null) ? "" : String(s);
  return s.replaceAll("&","&amp;").replaceAll("<","&lt;").replaceAll(">","&gt;");
}

function _pdfFindProposalText(){
  const el =
    document.getElementById("proposalText") ||
    document.getElementById("projectProposal") ||
    document.querySelector('textarea[name="proposal"]') ||
    document.querySelector('textarea[id*="proposal" i]');
  return el ? el.value : "";
}

function _pdfFindUpgrades(){
  const cards = Array.from(document.querySelectorAll(".upgradeCard"));
  const out = [];
  for (const card of cards){
    const isSel = card.classList.contains("selected") || card.classList.contains("active") || card.getAttribute("aria-pressed")==="true";
    if (!isSel) continue;
    const title = card.querySelector(".upgradeTitle")?.textContent?.trim() || card.textContent.trim().split("\n")[0];
    let amt = card.dataset.acceptedAmount || "";
    if (!amt){
      const t = card.querySelector(".upgradeAmount")?.textContent?.trim() || "";
      amt = (t && t !== "Accepted") ? t : "";
    }
    out.push({ title, amt });
  }
  return out;
}

function _pdfFindMeta(){
  const name = document.querySelector("#customerPanel input[id*='name' i], #customerPanel input[placeholder*='name' i]")?.value || "";
  const addr = document.querySelector("#customerPanel input[id*='address' i], #customerPanel input[placeholder*='address' i]")?.value || "";
  const city = document.querySelector("#customerPanel input[id*='city' i], #customerPanel input[placeholder*='city' i]")?.value || "";
  const zip  = document.querySelector("#customerPanel input[id*='zip' i], #customerPanel input[placeholder*='zip' i]")?.value || "";
  const phone = document.querySelector("#customerPanel input[id*='phone' i], #customerPanel input[placeholder*='phone' i]")?.value || "";
  const dateStr = new Date().toLocaleDateString();

  const parts = [];
  if (name) parts.push(name);
  const line2 = [addr, [city, zip].filter(Boolean).join(" ")].filter(Boolean).join("\n");
  if (line2) parts.push(line2);
  if (phone) parts.push(phone);
  parts.push("Date: " + dateStr);
  return parts.join("\n");
}

function renderEstimatePreview(){
  const host = document.getElementById("estimatePreviewContent");
  if (!host) return;

  // Canvas snapshot
  const c = document.getElementById("canvas");
  let img = "";
  try{ img = c ? c.toDataURL("image/png") : ""; }catch(_){ img = ""; }

  const proposal = _pdfFindProposalText();
  const meta = _pdfFindMeta();
  const upgrades = _pdfFindUpgrades();
  const upgradesTotal = document.getElementById("upgradesTotalValue")?.textContent || "";

  let upgradesHtml = "";
  if (!upgrades.length){
    upgradesHtml = '<div style="color:#666;font-style:italic;font-size:12px;">No upgrades selected</div>';
  } else {
    upgradesHtml = "<ul>" + upgrades.map(u => (
      "<li><span>"+_pdfEscape(u.title)+"</span><span>"+_pdfEscape(u.amt||"")+"</span></li>"
    )).join("") + "</ul>";
  }

  host.innerHTML =
    '<div class="pdfRoot" id="pdfTemplateRoot">' +
      '<div class="pdfHeader">' +
        '<div class="h1">Seamless Gutter Estimate</div>' +
        '<div class="meta">'+ _pdfEscape(meta).replaceAll("\n","<br>") +'</div>' +
      '</div>' +

      '<div class="pdfGrid">' +
        '<div class="pdfCanvasBox pdfNoBreak">' +
          (img ? '<img src="'+img+'" alt="Estimate drawing">' : '<div style="color:#666;">(No canvas image)</div>') +
        '</div>' +

        '<div class="pdfRight">' +
          '<div class="pdfUpgrades pdfNoBreak">' +
            '<div class="pdfSectionTitle">Upgrades</div>' +
            upgradesHtml +
            (upgradesTotal ? '<div class="pdfTotals"><div>Upgrades Total: '+_pdfEscape(upgradesTotal)+'</div></div>' : '') +
          '</div>' +

          '<div class="pdfProposal pdfNoBreak">' +
            '<div class="pdfSectionTitle">Proposal</div>' +
            '<div>'+ _pdfEscape(proposal).replaceAll("\n","<br>") +'</div>' +
          '</div>' +
        '</div>' +
      '</div>' +
    '</div>';
}

function downloadEstimatePDF(){
  try{
    if (typeof html2pdf === "undefined"){
      alert("PDF export library not loaded. If you opened this from a local file, you may need internet for the PDF library.");
      return;
    }
    renderEstimatePreview();
    const el = document.getElementById("pdfTemplateRoot");
    if (!el) return;

    html2pdf().set({
      margin: 0.35,
      filename: "Estimate.pdf",
      image: { type: "jpeg", quality: 0.98 },
      html2canvas: { scale: 2, useCORS: true, backgroundColor: "#ffffff", windowWidth: 816 },
      jsPDF: { unit: "in", format: "letter", orientation: "portrait" },
      pagebreak: { mode: ["css","legacy"] }
    }).from(el).save();
  }catch(e){
    console.error(e);
    alert("PDF export failed. Check the console for details.");
  }
}
/* ===== END PDF TEMPLATE OVERRIDES ===== */
</script>
</body>
</html>
